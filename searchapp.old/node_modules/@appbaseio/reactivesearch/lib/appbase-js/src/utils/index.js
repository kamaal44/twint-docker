'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.contains = contains;
exports.isAppbase = isAppbase;
exports.btoa = btoa;
exports.uuidv4 = uuidv4;
exports.validate = validate;
exports.removeUndefined = removeUndefined;
exports.waitForSocketConnection = waitForSocketConnection;
exports.encodeHeaders = encodeHeaders;
function contains(string, substring) {
  return string.indexOf(substring) !== -1;
}
function isAppbase(url) {
  return contains(url, 'scalr.api.appbase.io');
}
function btoa() {
  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var str = input;
  var output = '';

  // eslint-disable-next-line
  for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1); // eslint-disable-line no-bitwise
  output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
  ) {
    charCode = str.charCodeAt(i += 3 / 4);

    if (charCode > 0xff) {
      throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
    }

    block = block << 8 | charCode; // eslint-disable-line no-bitwise
  }

  return output;
}
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0; // eslint-disable-line no-bitwise

    var v = c === 'x' ? r : r & 0x3 | 0x8; // eslint-disable-line no-bitwise
    return v.toString(16);
  });
}
function validate(object, fields) {
  var invalid = [];
  var emptyFor = {
    object: null,
    string: ''
  };
  var keys = Object.keys(fields);
  keys.forEach(function (key) {
    var type = fields[key];
    // eslint-disable-next-line
    if (_typeof(object[key]) !== type || object[key] === emptyFor[type]) {
      invalid.push(key);
    }
  });
  var missing = '';
  for (var i = 0; i < invalid.length; i += 1) {
    missing += invalid[i] + ', ';
  }
  if (invalid.length > 0) {
    return new Error('fields missing: ' + missing);
  }

  return true;
}

function removeUndefined(value) {
  if (value || !(Object.keys(value).length === 0 && value.constructor === Object)) {
    return JSON.parse(JSON.stringify(value));
  }
  return null;
}

/**
 * Send only when a connection is opened
 * @param {Object} socket
 * @param {Function} callback
 */
function waitForSocketConnection(socket, callback) {
  setTimeout(function () {
    if (socket.readyState === 1) {
      if (callback != null) {
        callback();
      }
    } else {
      waitForSocketConnection(socket, callback);
    }
  }, 5); // wait 5 ms for the connection...
}

function encodeHeaders() {
  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var shouldEncode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  // Encode headers
  var encodedHeaders = {};
  if (shouldEncode) {
    Object.keys(headers).forEach(function (header) {
      encodedHeaders[header] = encodeURI(headers[header]);
    });
  } else {
    encodedHeaders = headers;
  }
  return encodedHeaders;
}