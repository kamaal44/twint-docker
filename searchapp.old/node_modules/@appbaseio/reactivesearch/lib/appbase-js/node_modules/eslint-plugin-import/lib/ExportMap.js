'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.recursivePatternCapture = recursivePatternCapture;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _doctrine = require('doctrine');

var _doctrine2 = _interopRequireDefault(_doctrine);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _parse = require('eslint-module-utils/parse');

var _parse2 = _interopRequireDefault(_parse);

var _resolve = require('eslint-module-utils/resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _ignore = require('eslint-module-utils/ignore');

var _ignore2 = _interopRequireDefault(_ignore);

var _hash = require('eslint-module-utils/hash');

var _unambiguous = require('eslint-module-utils/unambiguous');

var unambiguous = _interopRequireWildcard(_unambiguous);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var log = (0, _debug2.default)('eslint-plugin-import:ExportMap');

var exportCache = new Map();

var ExportMap = function () {
  function ExportMap(path) {
    _classCallCheck(this, ExportMap);

    this.path = path;
    this.namespace = new Map();
    // todo: restructure to key on path, value is resolver + map of names
    this.reexports = new Map();
    /**
     * star-exports
     * @type {Set} of () => ExportMap
     */
    this.dependencies = new Set();
    /**
     * dependencies of this module that are not explicitly re-exported
     * @type {Map} from path = () => ExportMap
     */
    this.imports = new Map();
    this.errors = [];
  }

  _createClass(ExportMap, [{
    key: 'has',


    /**
     * Note that this does not check explicitly re-exported names for existence
     * in the base namespace, but it will expand all `export * from '...'` exports
     * if not found in the explicit namespace.
     * @param  {string}  name
     * @return {Boolean} true if `name` is exported by this module.
     */
    value: function has(name) {
      if (this.namespace.has(name)) return true;
      if (this.reexports.has(name)) return true;

      // default exports must be explicitly re-exported (#328)
      if (name !== 'default') {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dep = _step.value;

            var innerMap = dep();

            // todo: report as unresolved?
            if (!innerMap) continue;

            if (innerMap.has(name)) return true;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return false;
    }

    /**
     * ensure that imported name fully resolves.
     * @param  {[type]}  name [description]
     * @return {Boolean}      [description]
     */

  }, {
    key: 'hasDeep',
    value: function hasDeep(name) {
      if (this.namespace.has(name)) return { found: true, path: [this] };

      if (this.reexports.has(name)) {
        var reexports = this.reexports.get(name),
            imported = reexports.getImport();

        // if import is ignored, return explicit 'null'
        if (imported == null) return { found: true, path: [this]

          // safeguard against cycles, only if name matches
        };if (imported.path === this.path && reexports.local === name) {
          return { found: false, path: [this] };
        }

        var deep = imported.hasDeep(reexports.local);
        deep.path.unshift(this);

        return deep;
      }

      // default exports must be explicitly re-exported (#328)
      if (name !== 'default') {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.dependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var dep = _step2.value;

            var innerMap = dep();
            // todo: report as unresolved?
            if (!innerMap) continue;

            // safeguard against cycles
            if (innerMap.path === this.path) continue;

            var innerValue = innerMap.hasDeep(name);
            if (innerValue.found) {
              innerValue.path.unshift(this);
              return innerValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return { found: false, path: [this] };
    }
  }, {
    key: 'get',
    value: function get(name) {
      if (this.namespace.has(name)) return this.namespace.get(name);

      if (this.reexports.has(name)) {
        var reexports = this.reexports.get(name),
            imported = reexports.getImport();

        // if import is ignored, return explicit 'null'
        if (imported == null) return null;

        // safeguard against cycles, only if name matches
        if (imported.path === this.path && reexports.local === name) return undefined;

        return imported.get(reexports.local);
      }

      // default exports must be explicitly re-exported (#328)
      if (name !== 'default') {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.dependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var dep = _step3.value;

            var innerMap = dep();
            // todo: report as unresolved?
            if (!innerMap) continue;

            // safeguard against cycles
            if (innerMap.path === this.path) continue;

            var innerValue = innerMap.get(name);
            if (innerValue !== undefined) return innerValue;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      return undefined;
    }
  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      var _this = this;

      this.namespace.forEach(function (v, n) {
        return callback.call(thisArg, v, n, _this);
      });

      this.reexports.forEach(function (reexports, name) {
        var reexported = reexports.getImport();
        // can't look up meta for ignored re-exports (#348)
        callback.call(thisArg, reexported && reexported.get(reexports.local), name, _this);
      });

      this.dependencies.forEach(function (dep) {
        var d = dep();
        // CJS / ignored dependencies won't exist (#717)
        if (d == null) return;

        d.forEach(function (v, n) {
          return n !== 'default' && callback.call(thisArg, v, n, _this);
        });
      });
    }

    // todo: keys, values, entries?

  }, {
    key: 'reportErrors',
    value: function reportErrors(context, declaration) {
      context.report({
        node: declaration.source,
        message: 'Parse errors in imported module \'' + declaration.source.value + '\': ' + ('' + this.errors.map(function (e) {
          return e.message + ' (' + e.lineNumber + ':' + e.column + ')';
        }).join(', '))
      });
    }
  }, {
    key: 'hasDefault',
    get: function get() {
      return this.get('default') != null;
    } // stronger than this.has

  }, {
    key: 'size',
    get: function get() {
      var size = this.namespace.size + this.reexports.size;
      this.dependencies.forEach(function (dep) {
        var d = dep();
        // CJS / ignored dependencies won't exist (#717)
        if (d == null) return;
        size += d.size;
      });
      return size;
    }
  }]);

  return ExportMap;
}();

exports.default = ExportMap; /**
                              * parse docs from the first node that has leading comments
                              * @param  {...[type]} nodes [description]
                              * @return {{doc: object}}
                              */

function captureDoc(docStyleParsers) {
  var metadata = {},
      nodes = Array.prototype.slice.call(arguments, 1);

  // 'some' short-circuits on first 'true'
  nodes.some(function (n) {
    if (!n.leadingComments) return false;

    for (var name in docStyleParsers) {
      var doc = docStyleParsers[name](n.leadingComments);
      if (doc) {
        metadata.doc = doc;
      }
    }

    return true;
  });

  return metadata;
}

var availableDocStyleParsers = {
  jsdoc: captureJsDoc,
  tomdoc: captureTomDoc

  /**
   * parse JSDoc from leading comments
   * @param  {...[type]} comments [description]
   * @return {{doc: object}}
   */
};function captureJsDoc(comments) {
  var doc = void 0;

  // capture XSDoc
  comments.forEach(function (comment) {
    // skip non-block comments
    if (comment.value.slice(0, 4) !== '*\n *') return;
    try {
      doc = _doctrine2.default.parse(comment.value, { unwrap: true });
    } catch (err) {
      /* don't care, for now? maybe add to `errors?` */
    }
  });

  return doc;
}

/**
  * parse TomDoc section from comments
  */
function captureTomDoc(comments) {
  // collect lines up to first paragraph break
  var lines = [];
  for (var i = 0; i < comments.length; i++) {
    var comment = comments[i];
    if (comment.value.match(/^\s*$/)) break;
    lines.push(comment.value.trim());
  }

  // return doctrine-like object
  var statusMatch = lines.join(' ').match(/^(Public|Internal|Deprecated):\s*(.+)/);
  if (statusMatch) {
    return {
      description: statusMatch[2],
      tags: [{
        title: statusMatch[1].toLowerCase(),
        description: statusMatch[2]
      }]
    };
  }
}

ExportMap.get = function (source, context) {
  var path = (0, _resolve2.default)(source, context);
  if (path == null) return null;

  return ExportMap.for(childContext(path, context));
};

ExportMap.for = function (context) {
  var path = context.path;

  var cacheKey = (0, _hash.hashObject)(context).digest('hex');
  var exportMap = exportCache.get(cacheKey);

  // return cached ignore
  if (exportMap === null) return null;

  var stats = _fs2.default.statSync(path);
  if (exportMap != null) {
    // date equality check
    if (exportMap.mtime - stats.mtime === 0) {
      return exportMap;
    }
    // future: check content equality?
  }

  // check valid extensions first
  if (!(0, _ignore.hasValidExtension)(path, context)) {
    exportCache.set(cacheKey, null);
    return null;
  }

  var content = _fs2.default.readFileSync(path, { encoding: 'utf8' });

  // check for and cache ignore
  if ((0, _ignore2.default)(path, context) || !unambiguous.test(content)) {
    log('ignored path due to unambiguous regex or ignore settings:', path);
    exportCache.set(cacheKey, null);
    return null;
  }

  log('cache miss', cacheKey, 'for path', path);
  exportMap = ExportMap.parse(path, content, context);

  // ambiguous modules return null
  if (exportMap == null) return null;

  exportMap.mtime = stats.mtime;

  exportCache.set(cacheKey, exportMap);
  return exportMap;
};

ExportMap.parse = function (path, content, context) {
  var m = new ExportMap(path);

  try {
    var ast = (0, _parse2.default)(path, content, context);
  } catch (err) {
    log('parse error:', path, err);
    m.errors.push(err);
    return m; // can't continue
  }

  if (!unambiguous.isModule(ast)) return null;

  var docstyle = context.settings && context.settings['import/docstyle'] || ['jsdoc'];
  var docStyleParsers = {};
  docstyle.forEach(function (style) {
    docStyleParsers[style] = availableDocStyleParsers[style];
  });

  // attempt to collect module doc
  if (ast.comments) {
    ast.comments.some(function (c) {
      if (c.type !== 'Block') return false;
      try {
        var doc = _doctrine2.default.parse(c.value, { unwrap: true });
        if (doc.tags.some(function (t) {
          return t.title === 'module';
        })) {
          m.doc = doc;
          return true;
        }
      } catch (err) {/* ignore */}
      return false;
    });
  }

  var namespaces = new Map();

  function remotePath(value) {
    return _resolve2.default.relative(value, path, context.settings);
  }

  function resolveImport(value) {
    var rp = remotePath(value);
    if (rp == null) return null;
    return ExportMap.for(childContext(rp, context));
  }

  function getNamespace(identifier) {
    if (!namespaces.has(identifier.name)) return;

    return function () {
      return resolveImport(namespaces.get(identifier.name));
    };
  }

  function addNamespace(object, identifier) {
    var nsfn = getNamespace(identifier);
    if (nsfn) {
      Object.defineProperty(object, 'namespace', { get: nsfn });
    }

    return object;
  }

  function captureDependency(declaration) {
    if (declaration.source == null) return null;

    var p = remotePath(declaration.source.value);
    if (p == null) return null;
    var existing = m.imports.get(p);
    if (existing != null) return existing.getter;

    var getter = function getter() {
      return ExportMap.for(childContext(p, context));
    };
    m.imports.set(p, {
      getter: getter,
      source: { // capturing actual node reference holds full AST in memory!
        value: declaration.source.value,
        loc: declaration.source.loc
      }
    });
    return getter;
  }

  ast.body.forEach(function (n) {

    if (n.type === 'ExportDefaultDeclaration') {
      var exportMeta = captureDoc(docStyleParsers, n);
      if (n.declaration.type === 'Identifier') {
        addNamespace(exportMeta, n.declaration);
      }
      m.namespace.set('default', exportMeta);
      return;
    }

    if (n.type === 'ExportAllDeclaration') {
      var getter = captureDependency(n);
      if (getter) m.dependencies.add(getter);
      return;
    }

    // capture namespaces in case of later export
    if (n.type === 'ImportDeclaration') {
      captureDependency(n);
      var ns = void 0;
      if (n.specifiers.some(function (s) {
        return s.type === 'ImportNamespaceSpecifier' && (ns = s);
      })) {
        namespaces.set(ns.local.name, n.source.value);
      }
      return;
    }

    if (n.type === 'ExportNamedDeclaration') {
      // capture declaration
      if (n.declaration != null) {
        switch (n.declaration.type) {
          case 'FunctionDeclaration':
          case 'ClassDeclaration':
          case 'TypeAlias': // flowtype with babel-eslint parser
          case 'InterfaceDeclaration':
          case 'TSEnumDeclaration':
          case 'TSInterfaceDeclaration':
          case 'TSAbstractClassDeclaration':
          case 'TSModuleDeclaration':
            m.namespace.set(n.declaration.id.name, captureDoc(docStyleParsers, n));
            break;
          case 'VariableDeclaration':
            n.declaration.declarations.forEach(function (d) {
              return recursivePatternCapture(d.id, function (id) {
                return m.namespace.set(id.name, captureDoc(docStyleParsers, d, n));
              });
            });
            break;
        }
      }

      var nsource = n.source && n.source.value;
      n.specifiers.forEach(function (s) {
        var exportMeta = {};
        var local = void 0;

        switch (s.type) {
          case 'ExportDefaultSpecifier':
            if (!n.source) return;
            local = 'default';
            break;
          case 'ExportNamespaceSpecifier':
            m.namespace.set(s.exported.name, Object.defineProperty(exportMeta, 'namespace', {
              get: function get() {
                return resolveImport(nsource);
              }
            }));
            return;
          case 'ExportSpecifier':
            if (!n.source) {
              m.namespace.set(s.exported.name, addNamespace(exportMeta, s.local));
              return;
            }
          // else falls through
          default:
            local = s.local.name;
            break;
        }

        // todo: JSDoc
        m.reexports.set(s.exported.name, { local: local, getImport: function getImport() {
            return resolveImport(nsource);
          } });
      });
    }
  });

  return m;
};

/**
 * Traverse a pattern/identifier node, calling 'callback'
 * for each leaf identifier.
 * @param  {node}   pattern
 * @param  {Function} callback
 * @return {void}
 */
function recursivePatternCapture(pattern, callback) {
  switch (pattern.type) {
    case 'Identifier':
      // base case
      callback(pattern);
      break;

    case 'ObjectPattern':
      pattern.properties.forEach(function (p) {
        recursivePatternCapture(p.value, callback);
      });
      break;

    case 'ArrayPattern':
      pattern.elements.forEach(function (element) {
        if (element == null) return;
        recursivePatternCapture(element, callback);
      });
      break;
  }
}

/**
 * don't hold full context object in memory, just grab what we need.
 */
function childContext(path, context) {
  var settings = context.settings,
      parserOptions = context.parserOptions,
      parserPath = context.parserPath;

  return {
    settings: settings,
    parserOptions: parserOptions,
    parserPath: parserPath,
    path: path
  };
}