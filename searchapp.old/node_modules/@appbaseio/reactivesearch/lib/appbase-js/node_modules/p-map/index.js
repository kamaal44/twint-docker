'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (iterable, mapper, opts) {
	return new Promise(function (resolve, reject) {
		opts = Object.assign({
			concurrency: Infinity
		}, opts);

		if (typeof mapper !== 'function') {
			throw new TypeError('Mapper function is required');
		}

		var concurrency = opts.concurrency;

		if (!(typeof concurrency === 'number' && concurrency >= 1)) {
			throw new TypeError('Expected `concurrency` to be a number from 1 and up, got `' + concurrency + '` (' + (typeof concurrency === 'undefined' ? 'undefined' : _typeof(concurrency)) + ')');
		}

		var ret = [];
		var iterator = iterable[Symbol.iterator]();
		var isRejected = false;
		var iterableDone = false;
		var resolvingCount = 0;
		var currentIdx = 0;

		var next = function next() {
			if (isRejected) {
				return;
			}

			var nextItem = iterator.next();
			var i = currentIdx;
			currentIdx++;

			if (nextItem.done) {
				iterableDone = true;

				if (resolvingCount === 0) {
					resolve(ret);
				}

				return;
			}

			resolvingCount++;

			Promise.resolve(nextItem.value).then(function (el) {
				return mapper(el, i);
			}).then(function (val) {
				ret[i] = val;
				resolvingCount--;
				next();
			}, function (err) {
				isRejected = true;
				reject(err);
			});
		};

		for (var i = 0; i < concurrency; i++) {
			next();

			if (iterableDone) {
				break;
			}
		}
	});
};