'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (str, count, opts) {
	// Support older versions: use the third parameter as options.indent
	// TODO: Remove the workaround in the next major version
	var options = (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) === 'object' ? Object.assign({ indent: ' ' }, opts) : { indent: opts || ' ' };
	count = count === undefined ? 1 : count;

	if (typeof str !== 'string') {
		throw new TypeError('Expected `input` to be a `string`, got `' + (typeof str === 'undefined' ? 'undefined' : _typeof(str)) + '`');
	}

	if (typeof count !== 'number') {
		throw new TypeError('Expected `count` to be a `number`, got `' + (typeof count === 'undefined' ? 'undefined' : _typeof(count)) + '`');
	}

	if (typeof options.indent !== 'string') {
		throw new TypeError('Expected `options.indent` to be a `string`, got `' + _typeof(options.indent) + '`');
	}

	if (count === 0) {
		return str;
	}

	var regex = options.includeEmptyLines ? /^/mg : /^(?!\s*$)/mg;
	return str.replace(regex, options.indent.repeat(count));
};