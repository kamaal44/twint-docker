'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _jestSnapshot;

function _load_jestSnapshot() {
  return _jestSnapshot = _interopRequireDefault(require('jest-snapshot'));
}

var _jestRegexUtil;

function _load_jestRegexUtil() {
  return _jestRegexUtil = require('jest-regex-util');
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var snapshotDirRegex = new RegExp((0, (_jestRegexUtil || _load_jestRegexUtil()).replacePathSepForRegex)('/__snapshots__/'));
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var snapshotFileRegex = new RegExp((0, (_jestRegexUtil || _load_jestRegexUtil()).replacePathSepForRegex)('__snapshots__/(.*).' + (_jestSnapshot || _load_jestSnapshot()).default.EXTENSION));
var isSnapshotPath = function isSnapshotPath(path) {
  return !!path.match(snapshotDirRegex);
};

/**
 * DependencyResolver is used to resolve the direct dependencies of a module or
 * to retrieve a list of all transitive inverse dependencies.
 */

var DependencyResolver = function () {
  function DependencyResolver(resolver, hasteFS) {
    _classCallCheck(this, DependencyResolver);

    this._resolver = resolver;
    this._hasteFS = hasteFS;
  }

  _createClass(DependencyResolver, [{
    key: 'resolve',
    value: function resolve(file, options) {
      var _this = this;

      var dependencies = this._hasteFS.getDependencies(file);
      if (!dependencies) {
        return [];
      }

      return dependencies.map(function (dependency) {
        if (_this._resolver.isCoreModule(dependency)) {
          return null;
        }
        try {
          return _this._resolver.resolveModule(file, dependency, options);
        } catch (e) {}
        return _this._resolver.getMockModule(file, dependency);
      }).filter(Boolean);
    }
  }, {
    key: 'resolveInverse',
    value: function resolveInverse(paths, filter, options) {
      var _this2 = this;

      if (!paths.size) {
        return [];
      }

      var collectModules = function collectModules(relatedPaths, moduleMap, changed) {
        var visitedModules = new Set();
        while (changed.size) {
          changed = new Set(moduleMap.filter(function (module) {
            return !visitedModules.has(module.file) && module.dependencies.some(function (dep) {
              return dep && changed.has(dep);
            });
          }).map(function (module) {
            var file = module.file;
            if (filter(file)) {
              relatedPaths.add(file);
            }
            visitedModules.add(file);
            return module.file;
          }));
        }
        return relatedPaths;
      };

      var relatedPaths = new Set();
      var changed = new Set();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var path = _step.value;

          if (this._hasteFS.exists(path)) {
            // /path/to/__snapshots__/test.js.snap is always adjacent to
            // /path/to/test.js
            var modulePath = isSnapshotPath(path) ? path.replace(snapshotFileRegex, '$1') : path;
            changed.add(modulePath);
            if (filter(modulePath)) {
              relatedPaths.add(modulePath);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var modules = this._hasteFS.getAllFiles().map(function (file) {
        return {
          dependencies: _this2.resolve(file, options),
          file: file
        };
      });
      return Array.from(collectModules(relatedPaths, modules, changed));
    }
  }]);

  return DependencyResolver;
}();

module.exports = DependencyResolver;