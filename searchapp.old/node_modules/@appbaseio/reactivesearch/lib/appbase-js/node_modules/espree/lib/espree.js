"use strict";

/* eslint-disable no-param-reassign*/

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var acorn = require("acorn");
var jsx = require("acorn-jsx");
var TokenTranslator = require("./token-translator");

var DEFAULT_ECMA_VERSION = 5;
var STATE = Symbol("espree's internal state");
var ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");
var tokTypes = Object.assign({}, acorn.tokTypes, jsx.tokTypes);

/**
 * Normalize ECMAScript version from the initial config
 * @param {number} ecmaVersion ECMAScript version from the initial config
 * @returns {number} normalized ECMAScript version
 */
function normalizeEcmaVersion(ecmaVersion) {
    if (typeof ecmaVersion === "number") {
        var version = ecmaVersion;

        // Calculate ECMAScript edition number from official year version starting with
        // ES2015, which corresponds with ES6 (or a difference of 2009).
        if (version >= 2015) {
            version -= 2009;
        }

        switch (version) {
            case 3:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
                return version;

            default:
                throw new Error("Invalid ecmaVersion.");
        }
    } else {
        return DEFAULT_ECMA_VERSION;
    }
}

/**
 * Converts an Acorn comment to a Esprima comment.
 * @param {boolean} block True if it's a block comment, false if not.
 * @param {string} text The text of the comment.
 * @param {int} start The index at which the comment starts.
 * @param {int} end The index at which the comment ends.
 * @param {Location} startLoc The location at which the comment starts.
 * @param {Location} endLoc The location at which the comment ends.
 * @returns {Object} The comment object.
 * @private
 */
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
        type: block ? "Block" : "Line",
        value: text
    };

    if (typeof start === "number") {
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
    }

    if ((typeof startLoc === "undefined" ? "undefined" : _typeof(startLoc)) === "object") {
        comment.loc = {
            start: startLoc,
            end: endLoc
        };
    }

    return comment;
}

module.exports = function () {
    return function (Parser) {
        return function (_Parser) {
            _inherits(Espree, _Parser);

            function Espree(options, code) {
                _classCallCheck(this, Espree);

                if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== "object" || options === null) {
                    options = {};
                }
                if (typeof code !== "string" && !(code instanceof String)) {
                    code = String(code);
                }

                var ecmaFeatures = options.ecmaFeatures || {};
                var ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
                var isModule = options.sourceType === "module";
                var tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code) : null;

                // Initialize acorn parser.

                // Initialize internal state.
                var _this = _possibleConstructorReturn(this, (Espree.__proto__ || Object.getPrototypeOf(Espree)).call(this, {
                    ecmaVersion: isModule ? Math.max(6, ecmaVersion) : ecmaVersion,
                    sourceType: isModule ? "module" : "script",
                    ranges: options.range === true,
                    locations: options.loc === true,

                    // Truthy value is true for backward compatibility.
                    allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),

                    // Collect tokens
                    onToken: function onToken(token) {
                        if (tokenTranslator) {

                            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.
                            tokenTranslator.onToken(token, _this[STATE]);
                        }
                        if (token.type !== tokTypes.eof) {
                            _this[STATE].lastToken = token;
                        }
                    },

                    // Collect comments
                    onComment: function onComment(block, text, start, end, startLoc, endLoc) {
                        if (_this[STATE].comments) {
                            var comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);

                            _this[STATE].comments.push(comment);
                        }
                    }
                }, code));

                _this[STATE] = {
                    tokens: tokenTranslator ? [] : null,
                    comments: options.comment === true ? [] : null,
                    impliedStrict: ecmaFeatures.impliedStrict === true && _this.options.ecmaVersion >= 5,
                    ecmaVersion: _this.options.ecmaVersion,
                    jsxAttrValueToken: false,
                    lastToken: null
                };
                return _this;
            }

            _createClass(Espree, [{
                key: "tokenize",
                value: function tokenize() {
                    do {
                        this.next();
                    } while (this.type !== tokTypes.eof);

                    var extra = this[STATE];
                    var tokens = extra.tokens;

                    if (extra.comments) {
                        tokens.comments = extra.comments;
                    }

                    return tokens;
                }
            }, {
                key: "finishNode",
                value: function finishNode() {
                    var _get2;

                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    var result = (_get2 = _get(Espree.prototype.__proto__ || Object.getPrototypeOf(Espree.prototype), "finishNode", this)).call.apply(_get2, [this].concat(args));

                    return this[ESPRIMA_FINISH_NODE](result);
                }
            }, {
                key: "finishNodeAt",
                value: function finishNodeAt() {
                    var _get3;

                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        args[_key2] = arguments[_key2];
                    }

                    var result = (_get3 = _get(Espree.prototype.__proto__ || Object.getPrototypeOf(Espree.prototype), "finishNodeAt", this)).call.apply(_get3, [this].concat(args));

                    return this[ESPRIMA_FINISH_NODE](result);
                }
            }, {
                key: "parse",
                value: function parse() {
                    var extra = this[STATE];
                    var program = _get(Espree.prototype.__proto__ || Object.getPrototypeOf(Espree.prototype), "parse", this).call(this);

                    program.sourceType = this.options.sourceType;

                    if (extra.comments) {
                        program.comments = extra.comments;
                    }
                    if (extra.tokens) {
                        program.tokens = extra.tokens;
                    }

                    /*
                     * Adjust opening and closing position of program to match Esprima.
                     * Acorn always starts programs at range 0 whereas Esprima starts at the
                     * first AST node's start (the only real difference is when there's leading
                     * whitespace or leading comments). Acorn also counts trailing whitespace
                     * as part of the program whereas Esprima only counts up to the last token.
                     */
                    if (program.range) {
                        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
                        program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];
                    }
                    if (program.loc) {
                        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
                        program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;
                    }

                    return program;
                }
            }, {
                key: "parseTopLevel",
                value: function parseTopLevel(node) {
                    if (this[STATE].impliedStrict) {
                        this.strict = true;
                    }
                    return _get(Espree.prototype.__proto__ || Object.getPrototypeOf(Espree.prototype), "parseTopLevel", this).call(this, node);
                }

                /**
                 * Overwrites the default raise method to throw Esprima-style errors.
                 * @param {int} pos The position of the error.
                 * @param {string} message The error message.
                 * @throws {SyntaxError} A syntax error.
                 * @returns {void}
                 */

            }, {
                key: "raise",
                value: function raise(pos, message) {
                    var loc = acorn.getLineInfo(this.input, pos);
                    var err = new SyntaxError(message);

                    err.index = pos;
                    err.lineNumber = loc.line;
                    err.column = loc.column + 1; // acorn uses 0-based columns
                    throw err;
                }

                /**
                 * Overwrites the default raise method to throw Esprima-style errors.
                 * @param {int} pos The position of the error.
                 * @param {string} message The error message.
                 * @throws {SyntaxError} A syntax error.
                 * @returns {void}
                 */

            }, {
                key: "raiseRecoverable",
                value: function raiseRecoverable(pos, message) {
                    this.raise(pos, message);
                }

                /**
                 * Overwrites the default unexpected method to throw Esprima-style errors.
                 * @param {int} pos The position of the error.
                 * @throws {SyntaxError} A syntax error.
                 * @returns {void}
                 */

            }, {
                key: "unexpected",
                value: function unexpected(pos) {
                    var message = "Unexpected token";

                    if (pos !== null && pos !== void 0) {
                        this.pos = pos;

                        if (this.options.locations) {
                            while (this.pos < this.lineStart) {
                                this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                                --this.curLine;
                            }
                        }

                        this.nextToken();
                    }

                    if (this.end > this.start) {
                        message += " " + this.input.slice(this.start, this.end);
                    }

                    this.raise(this.start, message);
                }

                /*
                 * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
                 * uses regular tt.string without any distinction between this and regular JS
                 * strings. As such, we intercept an attempt to read a JSX string and set a flag
                 * on extra so that when tokens are converted, the next token will be switched
                 * to JSXText via onToken.
                 */

            }, {
                key: "jsx_readString",
                value: function jsx_readString(quote) {
                    // eslint-disable-line camelcase
                    var result = _get(Espree.prototype.__proto__ || Object.getPrototypeOf(Espree.prototype), "jsx_readString", this).call(this, quote);

                    if (this.type === tokTypes.string) {
                        this[STATE].jsxAttrValueToken = true;
                    }
                    return result;
                }

                /**
                 * Performs last-minute Esprima-specific compatibility checks and fixes.
                 * @param {ASTNode} result The node to check.
                 * @returns {ASTNode} The finished node.
                 */

            }, {
                key: ESPRIMA_FINISH_NODE,
                value: function value(result) {

                    // Acorn doesn't count the opening and closing backticks as part of templates
                    // so we have to adjust ranges/locations appropriately.
                    if (result.type === "TemplateElement") {

                        // additional adjustment needed if ${ is the last token
                        var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";

                        if (result.range) {
                            result.range[0]--;
                            result.range[1] += terminalDollarBraceL ? 2 : 1;
                        }

                        if (result.loc) {
                            result.loc.start.column--;
                            result.loc.end.column += terminalDollarBraceL ? 2 : 1;
                        }
                    }

                    if (result.type.indexOf("Function") > -1 && !result.generator) {
                        result.generator = false;
                    }

                    return result;
                }
            }]);

            return Espree;
        }(Parser);
    };
};