'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _jestDiff = require('jest-diff');

var _jestDiff2 = _interopRequireDefault(_jestDiff);

var _jestGetType = require('jest-get-type');

var _jestGetType2 = _interopRequireDefault(_jestGetType);

var _jestRegexUtil = require('jest-regex-util');

var _jestMatcherUtils = require('jest-matcher-utils');

var _utils = require('./utils');

var _jasmine_utils = require('./jasmine_utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var matchers = {
  toBe: function toBe(received, expected) {
    var _this = this;

    var comment = 'Object.is equality';
    var pass = Object.is(received, expected);

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.toBe', undefined, undefined, {
        comment: comment,
        isNot: true
      }) + '\n\n' + ('Expected: ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + ('Received: ' + (0, _jestMatcherUtils.printReceived)(received));
    } : function () {
      var suggestToEqual = (0, _jestGetType2.default)(received) === (0, _jestGetType2.default)(expected) && ((0, _jestGetType2.default)(received) === 'object' || (0, _jestGetType2.default)(expected) === 'array') && (0, _jasmine_utils.equals)(received, expected, [_utils.iterableEquality]);
      var oneline = (0, _utils.isOneline)(expected, received);
      var diffString = (0, _jestDiff2.default)(expected, received, {
        expand: _this.expand
      });

      return (0, _jestMatcherUtils.matcherHint)('.toBe', undefined, undefined, {
        comment: comment,
        isNot: false
      }) + '\n\n' + ('Expected: ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + ('Received: ' + (0, _jestMatcherUtils.printReceived)(received)) + (diffString && !oneline ? '\n\nDifference:\n\n' + diffString : '') + (suggestToEqual ? ' ' + _jestMatcherUtils.SUGGEST_TO_EQUAL : '');
    };

    // Passing the the actual and expected objects so that a custom reporter
    // could access them, for example in order to display a custom visual diff,
    // or create a different error message
    return {
      actual: received,
      expected: expected,
      message: message,
      name: 'toBe',
      pass: pass
    };
  },
  toBeCloseTo: function toBeCloseTo(actual, expected) {
    var _this2 = this;

    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;

    var secondArgument = arguments.length === 3 ? 'precision' : null;
    (0, _jestMatcherUtils.ensureNumbers)(actual, expected, '.toBeCloseTo');
    var pass = Math.abs(expected - actual) < Math.pow(10, -precision) / 2;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeCloseTo', undefined, undefined, {
        isNot: _this2.isNot,
        secondArgument: secondArgument
      }) + '\n\n' + ('Precision: ' + (0, _jestMatcherUtils.printExpected)(precision) + '-digit\n') + ('Expected: ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };

    return { message: message, pass: pass };
  },
  toBeDefined: function toBeDefined(actual, expected) {
    var _this3 = this;

    (0, _jestMatcherUtils.ensureNoExpected)(expected, '.toBeDefined');
    var pass = actual !== void 0;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeDefined', 'received', '', {
        isNot: _this3.isNot
      }) + '\n\n' + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeFalsy: function toBeFalsy(actual, expected) {
    var _this4 = this;

    (0, _jestMatcherUtils.ensureNoExpected)(expected, '.toBeFalsy');
    var pass = !actual;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeFalsy', 'received', '', {
        isNot: _this4.isNot
      }) + '\n\n' + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeGreaterThan: function toBeGreaterThan(actual, expected) {
    var _this5 = this;

    (0, _jestMatcherUtils.ensureNumbers)(actual, expected, '.toBeGreaterThan');
    var pass = actual > expected;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeGreaterThan', undefined, undefined, {
        isNot: _this5.isNot
      }) + '\n\n' + ('Expected: ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeGreaterThanOrEqual: function toBeGreaterThanOrEqual(actual, expected) {
    var _this6 = this;

    (0, _jestMatcherUtils.ensureNumbers)(actual, expected, '.toBeGreaterThanOrEqual');
    var pass = actual >= expected;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeGreaterThanOrEqual', undefined, undefined, {
        isNot: _this6.isNot
      }) + '\n\n' + ('Expected: ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeInstanceOf: function toBeInstanceOf(received, constructor) {
    var _this7 = this;

    var constType = (0, _jestGetType2.default)(constructor);

    if (constType !== 'function') {
      throw new Error((0, _jestMatcherUtils.matcherHint)('.toBeInstanceOf', 'value', 'constructor', {
        isNot: this.isNot
      }) + '\n\n' + 'Expected constructor to be a function. Instead got:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(constType)));
    }
    var pass = received instanceof constructor;

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.toBeInstanceOf', 'value', 'constructor', {
        isNot: _this7.isNot
      }) + '\n\n' + ('Expected constructor: ' + (0, _jestMatcherUtils.EXPECTED_COLOR)(constructor.name || String(constructor)) + '\n') + ('Received value: ' + (0, _jestMatcherUtils.printReceived)(received));
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)('.toBeInstanceOf', 'value', 'constructor', {
        isNot: _this7.isNot
      }) + '\n\n' + ('Expected constructor: ' + (0, _jestMatcherUtils.EXPECTED_COLOR)(constructor.name || String(constructor)) + '\n') + ('Received constructor: ' + (0, _jestMatcherUtils.RECEIVED_COLOR)(received != null ? received.constructor && received.constructor.name : '') + '\n') + ('Received value: ' + (0, _jestMatcherUtils.printReceived)(received));
    };

    return { message: message, pass: pass };
  },
  toBeLessThan: function toBeLessThan(actual, expected) {
    var _this8 = this;

    (0, _jestMatcherUtils.ensureNumbers)(actual, expected, '.toBeLessThan');
    var pass = actual < expected;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeLessThan', undefined, undefined, {
        isNot: _this8.isNot
      }) + '\n\n' + ('Expected: ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeLessThanOrEqual: function toBeLessThanOrEqual(actual, expected) {
    var _this9 = this;

    (0, _jestMatcherUtils.ensureNumbers)(actual, expected, '.toBeLessThanOrEqual');
    var pass = actual <= expected;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeLessThanOrEqual', undefined, undefined, {
        isNot: _this9.isNot
      }) + '\n\n' + ('Expected: ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeNaN: function toBeNaN(actual, expected) {
    var _this10 = this;

    (0, _jestMatcherUtils.ensureNoExpected)(expected, '.toBeNaN');
    var pass = Number.isNaN(actual);
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeNaN', 'received', '', {
        isNot: _this10.isNot
      }) + '\n\n' + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeNull: function toBeNull(actual, expected) {
    var _this11 = this;

    (0, _jestMatcherUtils.ensureNoExpected)(expected, '.toBeNull');
    var pass = actual === null;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeNull', 'received', '', {
        isNot: _this11.isNot
      }) + '\n\n' + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeTruthy: function toBeTruthy(actual, expected) {
    var _this12 = this;

    (0, _jestMatcherUtils.ensureNoExpected)(expected, '.toBeTruthy');
    var pass = !!actual;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeTruthy', 'received', '', {
        isNot: _this12.isNot
      }) + '\n\n' + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };
    return { message: message, pass: pass };
  },
  toBeUndefined: function toBeUndefined(actual, expected) {
    var _this13 = this;

    (0, _jestMatcherUtils.ensureNoExpected)(expected, '.toBeUndefined');
    var pass = actual === void 0;
    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toBeUndefined', 'received', '', {
        isNot: _this13.isNot
      }) + '\n\n' + ('Received: ' + (0, _jestMatcherUtils.printReceived)(actual));
    };

    return { message: message, pass: pass };
  },
  toContain: function toContain(collection, value) {
    var collectionType = (0, _jestGetType2.default)(collection);

    var converted = null;
    if (Array.isArray(collection) || typeof collection === 'string') {
      // strings have `indexOf` so we don't need to convert
      // arrays have `indexOf` and we don't want to make a copy
      converted = collection;
    } else {
      try {
        converted = Array.from(collection);
      } catch (e) {
        throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toContainEqual', 'collection', 'value') + '\n\n' + ('Expected ' + (0, _jestMatcherUtils.RECEIVED_COLOR)('collection') + ' to be an array-like structure.\n') + (0, _jestMatcherUtils.printWithType)('Received', collection, _jestMatcherUtils.printReceived));
      }
    }
    // At this point, we're either a string or an Array,
    // which was converted from an array-like structure.
    var pass = converted.indexOf(value) != -1;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toContain', collectionType, 'value') + '\n\n' + ('Expected ' + collectionType + ':\n') + ('  ' + (0, _jestMatcherUtils.printReceived)(collection) + '\n') + 'Not to contain value:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(value) + '\n');
    } : function () {
      var suggestToContainEqual = converted !== null && typeof converted !== 'string' && converted instanceof Array && converted.findIndex(function (item) {
        return (0, _jasmine_utils.equals)(item, value, [_utils.iterableEquality]);
      }) !== -1;
      return (0, _jestMatcherUtils.matcherHint)('.toContain', collectionType, 'value') + '\n\n' + ('Expected ' + collectionType + ':\n') + ('  ' + (0, _jestMatcherUtils.printReceived)(collection) + '\n') + 'To contain value:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(value)) + (suggestToContainEqual ? '\n\n' + _jestMatcherUtils.SUGGEST_TO_CONTAIN_EQUAL : '');
    };

    return { message: message, pass: pass };
  },
  toContainEqual: function toContainEqual(collection, value) {
    var collectionType = (0, _jestGetType2.default)(collection);
    var converted = null;
    if (Array.isArray(collection)) {
      converted = collection;
    } else {
      try {
        converted = Array.from(collection);
      } catch (e) {
        throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toContainEqual', 'collection', 'value') + '\n\n' + ('Expected ' + (0, _jestMatcherUtils.RECEIVED_COLOR)('collection') + ' to be an array-like structure.\n') + (0, _jestMatcherUtils.printWithType)('Received', collection, _jestMatcherUtils.printReceived));
      }
    }

    var pass = converted.findIndex(function (item) {
      return (0, _jasmine_utils.equals)(item, value, [_utils.iterableEquality]);
    }) !== -1;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toContainEqual', collectionType, 'value') + '\n\n' + ('Expected ' + collectionType + ':\n') + ('  ' + (0, _jestMatcherUtils.printReceived)(collection) + '\n') + 'Not to contain a value equal to:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(value) + '\n');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)('.toContainEqual', collectionType, 'value') + '\n\n' + ('Expected ' + collectionType + ':\n') + ('  ' + (0, _jestMatcherUtils.printReceived)(collection) + '\n') + 'To contain a value equal to:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(value));
    };

    return { message: message, pass: pass };
  },
  toEqual: function toEqual(received, expected) {
    var _this14 = this;

    var pass = (0, _jasmine_utils.equals)(received, expected, [_utils.iterableEquality]);

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toEqual') + '\n\n' + 'Expected value to not equal:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received));
    } : function () {
      var oneline = (0, _utils.isOneline)(expected, received);
      var diffString = (0, _jestDiff2.default)(expected, received, {
        expand: _this14.expand
      });

      return (0, _jestMatcherUtils.matcherHint)('.toEqual') + '\n\n' + 'Expected value to equal:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received)) + (diffString && !oneline ? '\n\nDifference:\n\n' + diffString : '');
    };

    // Passing the the actual and expected objects so that a custom reporter
    // could access them, for example in order to display a custom visual diff,
    // or create a different error message
    return {
      actual: received,
      expected: expected,
      message: message,
      name: 'toEqual',
      pass: pass
    };
  },
  toHaveLength: function toHaveLength(received, length) {
    if (typeof received !== 'string' && (!received || typeof received.length !== 'number')) {
      throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toHaveLength', 'received', 'length') + '\n\n' + 'Expected value to have a \'length\' property that is a number. ' + 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received) + '\n') + (received ? 'received.length:\n  ' + (0, _jestMatcherUtils.printReceived)(received.length) : ''));
    }

    var pass = received.length === length;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toHaveLength', 'received', 'length') + '\n\n' + 'Expected value to not have length:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(length) + '\n') + 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received) + '\n') + 'received.length:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received.length));
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)('.toHaveLength', 'received', 'length') + '\n\n' + 'Expected value to have length:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(length) + '\n') + 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received) + '\n') + 'received.length:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received.length));
    };

    return { message: message, pass: pass };
  },
  toHaveProperty: function toHaveProperty(object, keyPath, value) {
    var _this15 = this;

    var valuePassed = arguments.length === 3;
    var secondArgument = valuePassed ? 'value' : null;

    if (!object && typeof object !== 'string' && typeof object !== 'number') {
      throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toHaveProperty', 'object', 'path', {
        secondArgument: secondArgument
      }) + '\n\n' + ('Expected ' + (0, _jestMatcherUtils.RECEIVED_COLOR)('object') + ' to be an object. Received:\n') + ('  ' + (0, _jestGetType2.default)(object) + ': ' + (0, _jestMatcherUtils.printReceived)(object)));
    }

    var keyPathType = (0, _jestGetType2.default)(keyPath);

    if (keyPathType !== 'string' && keyPathType !== 'array') {
      throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toHaveProperty', 'object', 'path', {
        secondArgument: secondArgument
      }) + '\n\n' + ('Expected ' + (0, _jestMatcherUtils.EXPECTED_COLOR)('path') + ' to be a string or an array. Received:\n') + ('  ' + (0, _jestGetType2.default)(keyPath) + ': ' + (0, _jestMatcherUtils.printReceived)(keyPath)));
    }

    var result = (0, _utils.getPath)(object, keyPath);
    var lastTraversedObject = result.lastTraversedObject,
        hasEndProp = result.hasEndProp;

    var pass = valuePassed ? (0, _jasmine_utils.equals)(result.value, value, [_utils.iterableEquality]) : hasEndProp;

    var traversedPath = result.traversedPath.join('.');

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toHaveProperty', 'object', 'path', {
        secondArgument: secondArgument
      }) + '\n\n' + 'Expected the object:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(object) + '\n') + 'Not to have a nested property:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(keyPath) + '\n') + (valuePassed ? 'With a value of:\n  ' + (0, _jestMatcherUtils.printExpected)(value) + '\n' : '');
    } : function () {
      var diffString = valuePassed && hasEndProp ? (0, _jestDiff2.default)(value, result.value, {
        expand: _this15.expand
      }) : '';
      return (0, _jestMatcherUtils.matcherHint)('.toHaveProperty', 'object', 'path', {
        secondArgument: secondArgument
      }) + '\n\n' + 'Expected the object:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(object) + '\n') + 'To have a nested property:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(keyPath) + '\n') + (valuePassed ? 'With a value of:\n  ' + (0, _jestMatcherUtils.printExpected)(value) + '\n' : '') + (hasEndProp ? 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(result.value)) + (diffString ? '\n\nDifference:\n\n' + diffString : '') : traversedPath ? 'Received:\n  ' + (0, _jestMatcherUtils.RECEIVED_COLOR)('object') + '.' + traversedPath + ': ' + (0, _jestMatcherUtils.printReceived)(lastTraversedObject) : '');
    };
    if (pass === undefined) {
      throw new Error('pass must be initialized');
    }

    return { message: message, pass: pass };
  },
  toMatch: function toMatch(received, expected) {
    if (typeof received !== 'string') {
      throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toMatch', 'string', 'expected') + '\n\n' + ((0, _jestMatcherUtils.RECEIVED_COLOR)('string') + ' value must be a string.\n') + (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived));
    }

    if (!(expected && typeof expected.test === 'function') && !(typeof expected === 'string')) {
      throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toMatch', 'string', 'expected') + '\n\n' + ((0, _jestMatcherUtils.EXPECTED_COLOR)('expected') + ' value must be a string or a regular expression.\n') + (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected));
    }

    var pass = new RegExp(typeof expected === 'string' ? (0, _jestRegexUtil.escapeStrForRegex)(expected) : expected).test(received);
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toMatch') + '\n\nExpected value not to match:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expected)) + '\nReceived:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received));
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)('.toMatch') + '\n\nExpected value to match:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expected)) + '\nReceived:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received));
    };

    return { message: message, pass: pass };
  },
  toMatchObject: function toMatchObject(receivedObject, expectedObject) {
    var _this16 = this;

    if ((typeof receivedObject === 'undefined' ? 'undefined' : _typeof(receivedObject)) !== 'object' || receivedObject === null) {
      throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toMatchObject', 'object', 'expected') + '\n\n' + ((0, _jestMatcherUtils.RECEIVED_COLOR)('received') + ' value must be an object.\n') + (0, _jestMatcherUtils.printWithType)('Received', receivedObject, _jestMatcherUtils.printReceived));
    }

    if ((typeof expectedObject === 'undefined' ? 'undefined' : _typeof(expectedObject)) !== 'object' || expectedObject === null) {
      throw new Error((0, _jestMatcherUtils.matcherHint)('[.not].toMatchObject', 'object', 'expected') + '\n\n' + ((0, _jestMatcherUtils.EXPECTED_COLOR)('expected') + ' value must be an object.\n') + (0, _jestMatcherUtils.printWithType)('Expected', expectedObject, _jestMatcherUtils.printExpected));
    }

    var pass = (0, _jasmine_utils.equals)(receivedObject, expectedObject, [_utils.iterableEquality, _utils.subsetEquality]);

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toMatchObject') + '\n\nExpected value not to match object:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expectedObject)) + '\nReceived:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(receivedObject));
    } : function () {
      var diffString = (0, _jestDiff2.default)(expectedObject, (0, _utils.getObjectSubset)(receivedObject, expectedObject), {
        expand: _this16.expand
      });
      return (0, _jestMatcherUtils.matcherHint)('.toMatchObject') + '\n\nExpected value to match object:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expectedObject)) + '\nReceived:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(receivedObject)) + (diffString ? '\nDifference:\n' + diffString : '');
    };

    return { message: message, pass: pass };
  },
  toStrictEqual: function toStrictEqual(received, expected) {
    var _this17 = this;

    var pass = (0, _jasmine_utils.equals)(received, expected, [_utils.iterableEquality, _utils.typeEquality], true);

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)('.not.toStrictEqual') + '\n\n' + 'Expected value to not equal:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received));
    } : function () {
      var diffString = (0, _jestDiff2.default)(expected, received, {
        expand: _this17.expand
      });
      return (0, _jestMatcherUtils.matcherHint)('.toStrictEqual') + '\n\n' + 'Expected value to equal:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expected) + '\n') + 'Received:\n' + ('  ' + (0, _jestMatcherUtils.printReceived)(received)) + (diffString ? '\n\nDifference:\n\n' + diffString : '');
    };

    // Passing the the actual and expected objects so that a custom reporter
    // could access them, for example in order to display a custom visual diff,
    // or create a different error message
    return {
      actual: received,
      expected: expected,
      message: message,
      name: 'toStrictEqual',
      pass: pass
    };
  }
};
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

exports.default = matchers;