'use strict';

var _templateObject = _taggedTemplateLiteral(['\n    ', ' "', '" found some errors. Please fix them and try committing again.\n    ', '\n    ', '\n  '], ['\n    ', ' "', '" found some errors. Please fix them and try committing again.\n    ', '\n    ', '\n  ']),
    _templateObject2 = _taggedTemplateLiteral(['\n        ', ' ', ' got an unexpected error.\n        ', '\n      '], ['\n        ', ' ', ' got an unexpected error.\n        ', '\n      ']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var chunk = require('lodash/chunk');
var dedent = require('dedent');
var isWindows = require('is-windows');
var execa = require('execa');
var symbols = require('log-symbols');
var pMap = require('p-map');
var calcChunkSize = require('./calcChunkSize');
var findBin = require('./findBin');

var debug = require('debug')('lint-staged:task');

/**
 * Execute the given linter binary with arguments and file paths using execa and
 * return the promise.
 *
 * @param {string} bin
 * @param {Array<string>} args
 * @param {Object} execaOptions
 * @param {Array<string>} pathsToLint
 * @return {Promise}
 */
function execLinter(bin, args, execaOptions, pathsToLint) {
  var binArgs = args.concat(pathsToLint);

  debug('bin:', bin);
  debug('args: %O', binArgs);
  debug('opts: %o', execaOptions);

  return execa(bin, binArgs, Object.assign({}, execaOptions));
}

var successMsg = function successMsg(linter) {
  return symbols.success + ' ' + linter + ' passed!';
};

/**
 * Create and returns an error instance with given stdout and stderr. If we set
 * the message on the error instance, it gets logged multiple times(see #142).
 * So we set the actual error message in a private field and extract it later,
 * log only once.
 *
 * @param {string} linter
 * @param {string} errStdout
 * @param {string} errStderr
 * @returns {Error}
 */
function makeErr(linter, errStdout, errStderr) {
  var err = new Error();
  err.privateMsg = dedent(_templateObject, symbols.error, linter, errStdout, errStderr);
  return err;
}

/**
 * Returns the task function for the linter. It handles chunking for file paths
 * if the OS is Windows.
 *
 * @param {Object} options
 * @param {string} options.linter
 * @param {string} options.gitDir
 * @param {Array<string>} options.pathsToLint
 * @param {number} options.chunkSize
 * @param {number} options.subTaskConcurrency
 * @returns {function(): Promise<string>}
 */
module.exports = function resolveTaskFn(options) {
  var linter = options.linter,
      gitDir = options.gitDir,
      pathsToLint = options.pathsToLint;

  var _findBin = findBin(linter),
      bin = _findBin.bin,
      args = _findBin.args;

  var execaOptions = { reject: false
    // Only use gitDir as CWD if we are using the git binary
    // e.g `npm` should run tasks in the actual CWD
  };if (/git(\.exe)?$/i.test(bin) && gitDir !== process.cwd()) {
    execaOptions.cwd = gitDir;
  }

  if (!isWindows()) {
    debug('%s  OS: %s; File path chunking unnecessary', symbols.success, process.platform);
    return function () {
      return execLinter(bin, args, execaOptions, pathsToLint).then(function (result) {
        if (!result.failed) return successMsg(linter);

        throw makeErr(linter, result.stdout, result.stderr);
      });
    };
  }

  var chunkSize = options.chunkSize,
      concurrency = options.subTaskConcurrency;


  var filePathChunks = chunk(pathsToLint, calcChunkSize(pathsToLint, chunkSize));
  var mapper = execLinter.bind(null, bin, args, execaOptions);

  debug('OS: %s; Creating linter task with %d chunked file paths', process.platform, filePathChunks.length);
  return function () {
    return pMap(filePathChunks, mapper, { concurrency: concurrency }).catch(function (err) {
      /* This will probably never be called. But just in case.. */
      throw new Error(dedent(_templateObject2, symbols.error, linter, err.message));
    }).then(function (results) {
      var errors = results.filter(function (res) {
        return res.failed;
      });
      if (errors.length === 0) return successMsg(linter);

      var errStdout = errors.map(function (err) {
        return err.stdout;
      }).join('');
      var errStderr = errors.map(function (err) {
        return err.stderr;
      }).join('');

      throw makeErr(linter, errStdout, errStderr);
    });
  };
};