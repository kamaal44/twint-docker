'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = undefined;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _micromatch = require('micromatch');

var _micromatch2 = _interopRequireDefault(_micromatch);

var _slash = require('slash');

var _slash2 = _interopRequireDefault(_slash);

var _codeFrame = require('@babel/code-frame');

var _stackUtils = require('stack-utils');

var _stackUtils2 = _interopRequireDefault(_stackUtils);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// stack utils tries to create pretty stack by making paths relative.
var stackUtils = new _stackUtils2.default({
  cwd: 'something which does not exist'
});
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var nodeInternals = [];

try {
  nodeInternals = _stackUtils2.default.nodeInternals()
  // this is to have the tests be the same in node 4 and node 6.
  // TODO: Remove when we drop support for node 4
  .concat(new RegExp('internal/process/next_tick.js'));
} catch (e) {
  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove
  // node internals in the browser though, so no issue.
}

var PATH_NODE_MODULES = _path2.default.sep + 'node_modules' + _path2.default.sep;
var PATH_JEST_PACKAGES = _path2.default.sep + 'jest' + _path2.default.sep + 'packages' + _path2.default.sep;

// filter for noisy stack trace lines
var JASMINE_IGNORE = /^\s+at(?:(?:.jasmine\-)|\s+jasmine\.buildExpectationResult)/;
var JEST_INTERNALS_IGNORE = /^\s+at.*?jest(-.*?)?(\/|\\)(build|node_modules|packages)(\/|\\)/;
var ANONYMOUS_FN_IGNORE = /^\s+at <anonymous>.*$/;
var ANONYMOUS_PROMISE_IGNORE = /^\s+at (new )?Promise \(<anonymous>\).*$/;
var ANONYMOUS_GENERATOR_IGNORE = /^\s+at Generator.next \(<anonymous>\).*$/;
var NATIVE_NEXT_IGNORE = /^\s+at next \(native\).*$/;
var TITLE_INDENT = '  ';
var MESSAGE_INDENT = '    ';
var STACK_INDENT = '      ';
var ANCESTRY_SEPARATOR = ' \u203A ';
var TITLE_BULLET = _chalk2.default.bold('\u25CF ');
var STACK_TRACE_COLOR = _chalk2.default.dim;
var STACK_PATH_REGEXP = /\s*at.*\(?(\:\d*\:\d*|native)\)?/;
var EXEC_ERROR_MESSAGE = 'Test suite failed to run';
var ERROR_TEXT = 'Error: ';

var indentAllLines = function indentAllLines(lines, indent) {
  return lines.split('\n').map(function (line) {
    return line ? indent + line : line;
  }).join('\n');
};

var trim = function trim(string) {
  return (string || '').trim();
};

// Some errors contain not only line numbers in stack traces
// e.g. SyntaxErrors can contain snippets of code, and we don't
// want to trim those, because they may have pointers to the column/character
// which will get misaligned.
var trimPaths = function trimPaths(string) {
  return string.match(STACK_PATH_REGEXP) ? trim(string) : string;
};

var getRenderedCallsite = function getRenderedCallsite(fileContent, line, column) {
  var renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, { start: { column: column, line: line } }, { highlightCode: true });

  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);

  renderedCallsite = '\n' + renderedCallsite + '\n';
  return renderedCallsite;
};

// ExecError is an error thrown outside of the test suite (not inside an `it` or
// `before/after each` hooks). If it's thrown, none of the tests in the file
// are executed.
var formatExecError = exports.formatExecError = function (error, config, options, testPath, reuseMessage) {
  if (!error || typeof error === 'number') {
    error = new Error('Expected an Error, but "' + String(error) + '" was thrown');
    error.stack = '';
  }

  var message = void 0,
      stack = void 0;

  if (typeof error === 'string' || !error) {
    error || (error = 'EMPTY ERROR');
    message = '';
    stack = error;
  } else {
    message = error.message;
    stack = error.stack;
  }

  var separated = separateMessageFromStack(stack || '');
  stack = separated.stack;

  if (separated.message.indexOf(trim(message)) !== -1) {
    // Often stack trace already contains the duplicate of the message
    message = separated.message;
  }

  message = indentAllLines(message, MESSAGE_INDENT);

  stack = stack && !options.noStackTrace ? '\n' + formatStackTrace(stack, config, options, testPath) : '';

  if (message.match(/^\s*$/) && stack.match(/^\s*$/)) {
    // this can happen if an empty object is thrown.
    message = MESSAGE_INDENT + 'Error: No message was provided';
  }

  var messageToUse = void 0;

  if (reuseMessage) {
    messageToUse = ' ' + message.trim();
  } else {
    messageToUse = EXEC_ERROR_MESSAGE + '\n\n' + message;
  }

  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\n';
};

var removeInternalStackEntries = function removeInternalStackEntries(lines, options) {
  var pathCounter = 0;

  return lines.filter(function (line) {
    if (ANONYMOUS_FN_IGNORE.test(line)) {
      return false;
    }

    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {
      return false;
    }

    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {
      return false;
    }

    if (NATIVE_NEXT_IGNORE.test(line)) {
      return false;
    }

    if (nodeInternals.some(function (internal) {
      return internal.test(line);
    })) {
      return false;
    }

    if (!STACK_PATH_REGEXP.test(line)) {
      return true;
    }

    if (JASMINE_IGNORE.test(line)) {
      return false;
    }

    if (++pathCounter === 1) {
      return true; // always keep the first line even if it's from Jest
    }

    if (options.noStackTrace) {
      return false;
    }

    if (JEST_INTERNALS_IGNORE.test(line)) {
      return false;
    }

    return true;
  });
};

var formatPaths = function formatPaths(config, relativeTestPath, line) {
  // Extract the file path from the trace line.
  var match = line.match(/(^\s*at .*?\(?)([^()]+)(:[0-9]+:[0-9]+\)?.*$)/);
  if (!match) {
    return line;
  }

  var filePath = (0, _slash2.default)(_path2.default.relative(config.rootDir, match[2]));
  // highlight paths from the current test file
  if (config.testMatch && config.testMatch.length && (0, _micromatch2.default)(filePath, config.testMatch) || filePath === relativeTestPath) {
    filePath = _chalk2.default.reset.cyan(filePath);
  }
  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);
};

var getStackTraceLines = exports.getStackTraceLines = function (stack) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { noStackTrace: false };
  return removeInternalStackEntries(stack.split(/\n/), options);
};

var getTopFrame = exports.getTopFrame = function (lines) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;

      if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {
        continue;
      }

      var parsedFrame = stackUtils.parseLine(line.trim());

      if (parsedFrame && parsedFrame.file) {
        return parsedFrame;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
};

var formatStackTrace = exports.formatStackTrace = function (stack, config, options, testPath) {
  var lines = getStackTraceLines(stack, options);
  var topFrame = getTopFrame(lines);
  var renderedCallsite = '';
  var relativeTestPath = testPath ? (0, _slash2.default)(_path2.default.relative(config.rootDir, testPath)) : null;

  if (topFrame) {
    var filename = topFrame.file;

    if (_path2.default.isAbsolute(filename)) {
      var fileContent = void 0;
      try {
        // TODO: check & read HasteFS instead of reading the filesystem:
        // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696
        fileContent = _fs2.default.readFileSync(filename, 'utf8');
        renderedCallsite = getRenderedCallsite(fileContent, topFrame.line, topFrame.column);
      } catch (e) {
        // the file does not exist or is inaccessible, we ignore
      }
    }
  }

  var stacktrace = lines.filter(Boolean).map(function (line) {
    return STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line));
  }).join('\n');

  return renderedCallsite + '\n' + stacktrace;
};

var formatResultsErrors = exports.formatResultsErrors = function (testResults, config, options, testPath) {
  var failedResults = testResults.reduce(function (errors, result) {
    result.failureMessages.forEach(function (content) {
      return errors.push({ content: content, result: result });
    });
    return errors;
  }, []);

  if (!failedResults.length) {
    return null;
  }

  return failedResults.map(function (_ref) {
    var result = _ref.result,
        content = _ref.content;

    var _separateMessageFromS = separateMessageFromStack(content);

    var message = _separateMessageFromS.message,
        stack = _separateMessageFromS.stack;

    stack = options.noStackTrace ? '' : STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) + '\n';

    message = indentAllLines(message, MESSAGE_INDENT);

    var title = _chalk2.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title) + '\n';

    return title + '\n' + message + '\n' + stack;
  }).join('\n');
};

// jasmine and worker farm sometimes don't give us access to the actual
// Error object, so we have to regexp out the message from the stack string
// to format it.
var separateMessageFromStack = exports.separateMessageFromStack = function (content) {
  if (!content) {
    return { message: '', stack: '' };
  }

  var messageMatch = content.match(/(^(.|\n)*?(?=\n\s*at\s.*\:\d*\:\d*))/);
  var message = messageMatch ? messageMatch[0] : 'Error';
  var stack = messageMatch ? content.slice(message.length) : content;
  // If the error is a plain error instead of a SyntaxError or TypeError
  // we remove it from the message because it is generally not useful.
  if (message.startsWith(ERROR_TEXT)) {
    message = message.substr(ERROR_TEXT.length);
  }
  return { message: message, stack: stack };
};