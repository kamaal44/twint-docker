"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var punycode = require("punycode");
var regexes = require("./lib/regexes.js");
var mappingTable = require("./lib/mappingTable.json");

function containsNonASCII(str) {
  return (/[^\x00-\x7F]/.test(str)
  );
}

function findStatus(val, _ref) {
  var useSTD3ASCIIRules = _ref.useSTD3ASCIIRules;

  var start = 0;
  var end = mappingTable.length - 1;

  while (start <= end) {
    var mid = Math.floor((start + end) / 2);

    var target = mappingTable[mid];
    if (target[0][0] <= val && target[0][1] >= val) {
      if (target[1].startsWith("disallowed_STD3_")) {
        var newStatus = useSTD3ASCIIRules ? "disallowed" : target[1].slice(16);
        return [newStatus].concat(_toConsumableArray(target.slice(2)));
      }
      return target.slice(1);
    } else if (target[0][0] > val) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return null;
}

function mapChars(domainName, _ref2) {
  var useSTD3ASCIIRules = _ref2.useSTD3ASCIIRules,
      processingOption = _ref2.processingOption;

  var hasError = false;
  var processed = "";

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = domainName[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var ch = _step.value;

      var _findStatus = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules: useSTD3ASCIIRules }),
          _findStatus2 = _slicedToArray(_findStatus, 2),
          status = _findStatus2[0],
          mapping = _findStatus2[1];

      switch (status) {
        case "disallowed":
          hasError = true;
          processed += ch;
          break;
        case "ignored":
          break;
        case "mapped":
          processed += mapping;
          break;
        case "deviation":
          if (processingOption === "transitional") {
            processed += mapping;
          } else {
            processed += ch;
          }
          break;
        case "valid":
          processed += ch;
          break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return {
    string: processed,
    error: hasError
  };
}

function validateLabel(label, _ref3) {
  var checkHyphens = _ref3.checkHyphens,
      checkBidi = _ref3.checkBidi,
      checkJoiners = _ref3.checkJoiners,
      processingOption = _ref3.processingOption,
      useSTD3ASCIIRules = _ref3.useSTD3ASCIIRules;

  if (label.normalize("NFC") !== label) {
    return false;
  }

  var codePoints = Array.from(label);

  if (checkHyphens) {
    if (codePoints[2] === "-" && codePoints[3] === "-" || label.startsWith("-") || label.endsWith("-")) {
      return false;
    }
  }

  if (label.includes(".") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {
    return false;
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = codePoints[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var ch = _step2.value;

      var _findStatus3 = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules: useSTD3ASCIIRules }),
          _findStatus4 = _slicedToArray(_findStatus3, 1),
          status = _findStatus4[0];

      if (processingOption === "transitional" && status !== "valid" || processingOption === "nontransitional" && status !== "valid" && status !== "deviation") {
        return false;
      }
    }

    // https://tools.ietf.org/html/rfc5892#appendix-A
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (checkJoiners) {
    var last = 0;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = codePoints.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _ref4 = _step3.value;

        var _ref5 = _slicedToArray(_ref4, 2);

        var i = _ref5[0];
        var _ch = _ref5[1];

        if (_ch === "\u200C" || _ch === "\u200D") {
          if (i > 0) {
            if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
              continue;
            }
            if (_ch === "\u200C") {
              // TODO: make this more efficient
              var next = codePoints.indexOf("\u200C", i + 1);
              var test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
              if (regexes.validZWNJ.test(test.join(""))) {
                last = i + 1;
                continue;
              }
            }
          }
          return false;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  // https://tools.ietf.org/html/rfc5893#section-2
  if (checkBidi) {
    var rtl = void 0;

    // 1
    if (regexes.bidiS1LTR.test(codePoints[0])) {
      rtl = false;
    } else if (regexes.bidiS1RTL.test(codePoints[0])) {
      rtl = true;
    } else {
      return false;
    }

    if (rtl) {
      // 2-4
      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
        return false;
      }
    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
      // 5-6
      return false;
    }
  }

  return true;
}

function isBidiDomain(labels) {
  var domain = labels.map(function (label) {
    if (label.startsWith("xn--")) {
      try {
        return punycode.decode(label.substring(4));
      } catch (err) {
        return "";
      }
    }
    return label;
  }).join(".");
  return regexes.bidiDomain.test(domain);
}

function processing(domainName, options) {
  var processingOption = options.processingOption;

  // 1. Map.

  var _mapChars = mapChars(domainName, options),
      string = _mapChars.string,
      error = _mapChars.error;

  // 2. Normalize.


  string = string.normalize("NFC");

  // 3. Break.
  var labels = string.split(".");
  var isBidi = isBidiDomain(labels);

  // 4. Convert/Validate.
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = labels.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _ref6 = _step4.value;

      var _ref7 = _slicedToArray(_ref6, 2);

      var i = _ref7[0];
      var origLabel = _ref7[1];

      var label = origLabel;
      var curProcessing = processingOption;
      if (label.startsWith("xn--")) {
        try {
          label = punycode.decode(label.substring(4));
          labels[i] = label;
        } catch (err) {
          error = true;
          continue;
        }
        curProcessing = "nontransitional";
      }

      // No need to validate if we already know there is an error.
      if (error) {
        continue;
      }
      var validation = validateLabel(label, Object.assign({}, options, {
        processingOption: curProcessing,
        checkBidi: options.checkBidi && isBidi
      }));
      if (!validation) {
        error = true;
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return {
    string: labels.join("."),
    error: error
  };
}

function toASCII(domainName) {
  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref8$checkHyphens = _ref8.checkHyphens,
      checkHyphens = _ref8$checkHyphens === undefined ? false : _ref8$checkHyphens,
      _ref8$checkBidi = _ref8.checkBidi,
      checkBidi = _ref8$checkBidi === undefined ? false : _ref8$checkBidi,
      _ref8$checkJoiners = _ref8.checkJoiners,
      checkJoiners = _ref8$checkJoiners === undefined ? false : _ref8$checkJoiners,
      _ref8$useSTD3ASCIIRul = _ref8.useSTD3ASCIIRules,
      useSTD3ASCIIRules = _ref8$useSTD3ASCIIRul === undefined ? false : _ref8$useSTD3ASCIIRul,
      _ref8$processingOptio = _ref8.processingOption,
      processingOption = _ref8$processingOptio === undefined ? "nontransitional" : _ref8$processingOptio,
      _ref8$verifyDNSLength = _ref8.verifyDNSLength,
      verifyDNSLength = _ref8$verifyDNSLength === undefined ? false : _ref8$verifyDNSLength;

  if (processingOption !== "transitional" && processingOption !== "nontransitional") {
    throw new RangeError("processingOption must be either transitional or nontransitional");
  }

  var result = processing(domainName, {
    processingOption: processingOption,
    checkHyphens: checkHyphens,
    checkBidi: checkBidi,
    checkJoiners: checkJoiners,
    useSTD3ASCIIRules: useSTD3ASCIIRules
  });
  var labels = result.string.split(".");
  labels = labels.map(function (l) {
    if (containsNonASCII(l)) {
      try {
        return "xn--" + punycode.encode(l);
      } catch (e) {
        result.error = true;
      }
    }
    return l;
  });

  if (verifyDNSLength) {
    var total = labels.join(".").length;
    if (total > 253 || total === 0) {
      result.error = true;
    }

    for (var i = 0; i < labels.length; ++i) {
      if (labels[i].length > 63 || labels[i].length === 0) {
        result.error = true;
        break;
      }
    }
  }

  if (result.error) {
    return null;
  }
  return labels.join(".");
}

function toUnicode(domainName) {
  var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref9$checkHyphens = _ref9.checkHyphens,
      checkHyphens = _ref9$checkHyphens === undefined ? false : _ref9$checkHyphens,
      _ref9$checkBidi = _ref9.checkBidi,
      checkBidi = _ref9$checkBidi === undefined ? false : _ref9$checkBidi,
      _ref9$checkJoiners = _ref9.checkJoiners,
      checkJoiners = _ref9$checkJoiners === undefined ? false : _ref9$checkJoiners,
      _ref9$useSTD3ASCIIRul = _ref9.useSTD3ASCIIRules,
      useSTD3ASCIIRules = _ref9$useSTD3ASCIIRul === undefined ? false : _ref9$useSTD3ASCIIRul;

  var result = processing(domainName, {
    processingOption: "nontransitional",
    checkHyphens: checkHyphens,
    checkBidi: checkBidi,
    checkJoiners: checkJoiners,
    useSTD3ASCIIRules: useSTD3ASCIIRules
  });

  return {
    domain: result.string,
    error: result.error
  };
}

module.exports = {
  toASCII: toASCII,
  toUnicode: toUnicode
};