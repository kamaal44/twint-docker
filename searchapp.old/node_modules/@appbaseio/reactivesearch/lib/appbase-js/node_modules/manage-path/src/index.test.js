'use strict';

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _getPathVar = require('./get-path-var');

var _getPathVar2 = _interopRequireDefault(_getPathVar);

var _getSeparator = require('./get-separator');

var _getSeparator2 = _interopRequireDefault(_getSeparator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var expect = _chai2.default.expect;

_chai2.default.use(require('chai-string'));

describe('manage-path', function () {
  var path1 = '/usr/other/bin';
  var path2 = '/usr/other2/bin';

  describe('darwin', function () {
    common('darwin');
  });

  describe('win32', function () {
    common('win32');
  });

  describe('outliers', function () {
    it('should function without a given env or platform', function () {
      var alter = (0, _index2.default)();
      expect(alter.push(path1)).to.equal(path1);
    });

    it('should default to process.platform for the platform', function () {
      var env = {};
      var alter = (0, _index2.default)({ env: env }, {});
      expect(alter.push(path2)).to.equal(path2);
    });
  });

  function common(platform) {
    var pathVar = (0, _getPathVar2.default)({}, platform);
    var separator = (0, _getSeparator2.default)(platform);
    var originalPath = '/usr/bin' + separator + '~/.bin';

    var alter = void 0,
        env = void 0;
    beforeEach(function () {
      env = _defineProperty({ USER: 'lukeskywalker' }, pathVar, originalPath);
      alter = (0, _index2.default)(env, { platform: platform });
    });

    describe('unshift', function () {
      addOpTests('unshift');
    });

    describe('push', function () {
      addOpTests('push');
    });

    describe('get', function () {
      it('should return the current state of env\'s PATH variable', function () {
        var result = alter.get();
        expect(result).to.equal(env[pathVar]);
      });
    });

    describe('restore', function () {
      it('should restore the original state of env\'s PATH variable', function () {
        var pushedValue = alter.push(path1);
        var result = alter.restore();
        var get = alter.get();
        expect(pushedValue).to.not.equal(result);
        expect(result).to.equal(get);
        expect(result).to.equal(originalPath);
      });
    });

    function addOpTests(op) {
      var reverse = op === 'push';
      it('should prepend a single path', function () {
        var result = alter[op](path1);
        var expected = [path1, originalPath];
        if (reverse) {
          expected = expected.reverse();
        }
        expect(result).to.equal(expected.join(separator));
      });

      it('should prepend multiple paths with rest params', function () {
        var result = alter[op](path1, path2);
        var expected = [path1, path2, originalPath];
        if (reverse) {
          expected = [originalPath, path1, path2];
        }
        expect(result).to.equal(expected.join(separator));
      });

      it('should prepend multiple paths as an array', function () {
        var result = alter[op]([path1, path2]);
        var expected = [path1, path2, originalPath];
        if (reverse) {
          expected = [originalPath, path1, path2];
        }
        expect(result).to.equal(expected.join(separator));
      });
    }
  }
});

/*
describe('add-to-path', () => {
  let originalPath
  const pathToAdd = '/foo/bar/.bin'

  beforeEach(() => {
    originalPath = env[PATH]
  })

  describe('platform independent', () => {
    it('should throw an error when passed a non-string', () => {
      expect(() => {
        addToPath()
      }).to.throw(/must pass a non-empty string/ig)
    })

    it('should throw an error when passed an empty string', () => {
      expect(() => {
        addToPath(2)
      }).to.throw(/must pass a non-empty string/ig)
    })

    it('should return a function to restore the path', () => {
      const restorePath = addToPath(pathToAdd)
      expect(env[PATH]).to.startWith(pathToAdd)
      restorePath()
      expect(env[PATH]).to.not.contain(pathToAdd)
    })

    it('should handle the case where there is no pre-existing path', () => {
      delete env[PATH]
      addToPath(pathToAdd)
      expect(env[PATH]).to.equal(pathToAdd)
    })

    it('should handle an array of strings', () => {
      const platform = 'darwin'
      const separator = ':'
      const paths = [pathToAdd, '/bar/foo/.bin']
      addToPath(paths, {platform})
      expect(env[PATH]).to.startWith(paths.join(separator))
    })

    it('should allow you to append to the path', () => {
      addToPath(pathToAdd, {append: true})
      expect(env[PATH]).to.endWith(pathToAdd)
    })
  })

  describe('on darwin platform', () => {
    const platform = 'darwin'
    const separator = ':'

    it('should alter the path to add what is provided', () => {
      expect(addToPath(pathToAdd, {platform}))
      expect(env[PATH]).to.startWith(pathToAdd + separator)
    })
  })

  describe('on win32 platform', () => {
    const platform = 'win32'
    const separator = ';'

    it('should alter the path to add what is provided', () => {
      expect(addToPath(pathToAdd, {platform}))
      expect(env[PATH]).to.startWith(pathToAdd + separator)
    })
  })

  afterEach(() => {
    env[PATH] = originalPath
  })
})

*/