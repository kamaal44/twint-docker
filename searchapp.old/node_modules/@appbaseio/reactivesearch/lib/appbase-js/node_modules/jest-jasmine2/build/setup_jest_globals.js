'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _expect = require('expect');

var _jestSnapshot = require('jest-snapshot');

// Get suppressed errors form  jest-matchers that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var addSuppressedErrors = function addSuppressedErrors(result) {
  var _getState = (0, _expect.getState)();

  var suppressedErrors = _getState.suppressedErrors;

  (0, _expect.setState)({ suppressedErrors: [] });
  if (suppressedErrors.length) {
    result.status = 'failed';

    result.failedExpectations = suppressedErrors.map(function (error) {
      return {
        actual: '',
        // passing error for custom test reporters
        error: error,
        expected: '',
        message: error.message,
        passed: false,
        stack: error.stack
      };
    });
  }
};

var addAssertionErrors = function addAssertionErrors(result) {
  var assertionErrors = (0, _expect.extractExpectedAssertionsErrors)();
  if (assertionErrors.length) {
    var jasmineErrors = assertionErrors.map(function (_ref) {
      var actual = _ref.actual,
          error = _ref.error,
          expected = _ref.expected;
      return {
        actual: actual,
        expected: expected,
        message: error.stack,
        passed: false
      };
    });
    result.status = 'failed';
    result.failedExpectations = result.failedExpectations.concat(jasmineErrors);
  }
};

var patchJasmine = function patchJasmine() {
  global.jasmine.Spec = function (realSpec) {
    var Spec = function Spec(attr) {
      var resultCallback = attr.resultCallback;
      attr.resultCallback = function (result) {
        addSuppressedErrors(result);
        addAssertionErrors(result);
        resultCallback.call(attr, result);
      };
      var onStart = attr.onStart;
      attr.onStart = function (context) {
        (0, _expect.setState)({ currentTestName: context.getFullName() });
        onStart && onStart.call(attr, context);
      };
      realSpec.call(this, attr);
    };

    Spec.prototype = realSpec.prototype;
    for (var statics in realSpec) {
      if (Object.prototype.hasOwnProperty.call(realSpec, statics)) {
        Spec[statics] = realSpec[statics];
      }
    }
    return Spec;
  }(global.jasmine.Spec);
};

exports.default = function (_ref2) {
  var config = _ref2.config,
      globalConfig = _ref2.globalConfig,
      localRequire = _ref2.localRequire,
      testPath = _ref2.testPath;

  // Jest tests snapshotSerializers in order preceding built-in serializers.
  // Therefore, add in reverse because the last added is the first tested.
  config.snapshotSerializers.concat().reverse().forEach(function (path) {
    (0, _jestSnapshot.addSerializer)(localRequire(path));
  });
  patchJasmine();
  var expand = globalConfig.expand,
      updateSnapshot = globalConfig.updateSnapshot;

  var snapshotState = new _jestSnapshot.SnapshotState(testPath, {
    expand: expand,
    getBabelTraverse: function getBabelTraverse() {
      return require('babel-traverse').default;
    },
    getPrettier: function getPrettier() {
      return (
        // $FlowFixMe dynamic require
        config.prettierPath ? require(config.prettierPath) : null
      );
    },
    updateSnapshot: updateSnapshot
  });
  (0, _expect.setState)({ snapshotState: snapshotState, testPath: testPath });
  // Return it back to the outer scope (test runner outside the VM).
  return snapshotState;
};