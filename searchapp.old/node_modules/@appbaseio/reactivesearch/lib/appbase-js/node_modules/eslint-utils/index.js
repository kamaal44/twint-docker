/*! @author Toru Nagashima <https://github.com/mysticatea> */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Get the innermost scope which contains a given location.
 * @param {Scope} initialScope The initial scope to search.
 * @param {Node} node The location to search.
 * @returns {Scope} The innermost scope.
 */
function getInnermostScope(initialScope, node) {
    var location = node.range[0];

    var scope = initialScope;
    var found = false;
    do {
        found = false;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = scope.childScopes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var childScope = _step.value;

                var range = childScope.block.range;

                if (range[0] <= location && location < range[1]) {
                    scope = childScope;
                    found = true;
                    break;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    } while (found);

    return scope;
}

/**
 * Find the variable of a given name.
 * @param {Scope} initialScope The scope to start finding.
 * @param {string|Node} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.
 * @returns {Variable|null} The found variable or null.
 */
function findVariable(initialScope, nameOrNode) {
    var name = "";
    var scope = initialScope;

    if (typeof nameOrNode === "string") {
        name = nameOrNode;
    } else {
        name = nameOrNode.name;
        scope = getInnermostScope(scope, nameOrNode);
    }

    while (scope != null) {
        var variable = scope.set.get(name);
        if (variable != null) {
            return variable;
        }
        scope = scope.upper;
    }

    return null;
}

/**
 * Negate the result of `this` calling.
 * @param {Token} token The token to check.
 * @returns {boolean} `true` if the result of `this(token)` is `false`.
 */
function negate0(token) {
    return !this(token); //eslint-disable-line no-invalid-this
}

/**
 * Creates the negate function of the given function.
 * @param {function(Token):boolean} f - The function to negate.
 * @returns {function(Token):boolean} Negated function.
 */
function negate(f) {
    return negate0.bind(f);
}

/**
 * Checks if the given token is an arrow token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an arrow token.
 */
function isArrowToken(token) {
    return token.value === "=>" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a comma token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comma token.
 */
function isCommaToken(token) {
    return token.value === "," && token.type === "Punctuator";
}

/**
 * Checks if the given token is a semicolon token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a semicolon token.
 */
function isSemicolonToken(token) {
    return token.value === ";" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a colon token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a colon token.
 */
function isColonToken(token) {
    return token.value === ":" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening parenthesis token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening parenthesis token.
 */
function isOpeningParenToken(token) {
    return token.value === "(" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing parenthesis token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing parenthesis token.
 */
function isClosingParenToken(token) {
    return token.value === ")" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening square bracket token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening square bracket token.
 */
function isOpeningBracketToken(token) {
    return token.value === "[" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing square bracket token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing square bracket token.
 */
function isClosingBracketToken(token) {
    return token.value === "]" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening brace token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening brace token.
 */
function isOpeningBraceToken(token) {
    return token.value === "{" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing brace token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing brace token.
 */
function isClosingBraceToken(token) {
    return token.value === "}" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a comment token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comment token.
 */
function isCommentToken(token) {
    return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
}

var isNotArrowToken = negate(isArrowToken);
var isNotCommaToken = negate(isCommaToken);
var isNotSemicolonToken = negate(isSemicolonToken);
var isNotColonToken = negate(isColonToken);
var isNotOpeningParenToken = negate(isOpeningParenToken);
var isNotClosingParenToken = negate(isClosingParenToken);
var isNotOpeningBracketToken = negate(isOpeningBracketToken);
var isNotClosingBracketToken = negate(isClosingBracketToken);
var isNotOpeningBraceToken = negate(isOpeningBraceToken);
var isNotClosingBraceToken = negate(isClosingBraceToken);
var isNotCommentToken = negate(isCommentToken);

/**
 * Get the `(` token of the given function node.
 * @param {Node} node - The function node to get.
 * @param {SourceCode} sourceCode - The source code object to get tokens.
 * @returns {Token} `(` token.
 */
function getOpeningParenOfParams(node, sourceCode) {
    return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
}

/**
 * Get the location of the given function node for reporting.
 * @param {Node} node - The function node to get.
 * @param {SourceCode} sourceCode - The source code object to get tokens.
 * @returns {string} The location of the function node for reporting.
 */
function getFunctionHeadLocation(node, sourceCode) {
    var parent = node.parent;
    var start = null;
    var end = null;

    if (node.type === "ArrowFunctionExpression") {
        var arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);

        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
    } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
        start = parent.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
    } else {
        start = node.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
    }

    return {
        start: Object.assign({}, start),
        end: Object.assign({}, end)
    };
}

var builtinNames = Object.freeze(new Set(["Array", "ArrayBuffer", "Boolean", "DataView", "Date", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Error", "escape", "EvalError", "Float32Array", "Float64Array", "Function", "Infinity", "Int16Array", "Int32Array", "Int8Array", "isFinite", "isNaN", "isPrototypeOf", "JSON", "Map", "Math", "NaN", "Number", "Object", "parseFloat", "parseInt", "Promise", "Proxy", "RangeError", "ReferenceError", "Reflect", "RegExp", "Set", "String", "Symbol", "SyntaxError", "TypeError", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray", "undefined", "unescape", "URIError", "WeakMap", "WeakSet"]));

/**
 * Get the element values of a given node list.
 * @param {Node[]} nodeList The node list to get values.
 * @param {Scope|undefined} initialScope The initial scope to find variables.
 * @returns {any[]|null} The value list if all nodes are constant. Otherwise, null.
 */
function getElementValues(nodeList, initialScope) {
    var valueList = [];

    for (var i = 0; i < nodeList.length; ++i) {
        var elementNode = nodeList[i];

        if (elementNode == null) {
            valueList.length = i + 1;
        } else if (elementNode.type === "SpreadElement") {
            var argument = getStaticValueR(elementNode.argument, initialScope);
            if (argument == null) {
                return null;
            }
            valueList.push.apply(valueList, _toConsumableArray(argument.value));
        } else {
            var element = getStaticValueR(elementNode, initialScope);
            if (element == null) {
                return null;
            }
            valueList.push(element.value);
        }
    }

    return valueList;
}

var operations = Object.freeze({
    ArrayExpression: function ArrayExpression(node, initialScope) {
        var elements = getElementValues(node.elements, initialScope);
        return elements != null ? { value: elements } : null;
    },
    AssignmentExpression: function AssignmentExpression(node, initialScope) {
        if (node.operator === "=") {
            return getStaticValueR(node.right, initialScope);
        }
        return null;
    },


    //eslint-disable-next-line complexity
    BinaryExpression: function BinaryExpression(node, initialScope) {
        if (node.operator === "in" || node.operator === "instanceof") {
            // Not supported.
            return null;
        }

        var left = getStaticValueR(node.left, initialScope);
        var right = getStaticValueR(node.right, initialScope);
        if (left != null && right != null) {
            switch (node.operator) {
                case "==":
                    return { value: left.value == right.value //eslint-disable-line eqeqeq
                    };case "!=":
                    return { value: left.value != right.value //eslint-disable-line eqeqeq
                    };case "===":
                    return { value: left.value === right.value };
                case "!==":
                    return { value: left.value !== right.value };
                case "<":
                    return { value: left.value < right.value };
                case "<=":
                    return { value: left.value <= right.value };
                case ">":
                    return { value: left.value > right.value };
                case ">=":
                    return { value: left.value >= right.value };
                case "<<":
                    return { value: left.value << right.value };
                case ">>":
                    return { value: left.value >> right.value };
                case ">>>":
                    return { value: left.value >>> right.value };
                case "+":
                    return { value: left.value + right.value };
                case "-":
                    return { value: left.value - right.value };
                case "*":
                    return { value: left.value * right.value };
                case "/":
                    return { value: left.value / right.value };
                case "%":
                    return { value: left.value % right.value };
                case "**":
                    return { value: Math.pow(left.value, right.value) };
                case "|":
                    return { value: left.value | right.value };
                case "^":
                    return { value: left.value ^ right.value };
                case "&":
                    return { value: left.value & right.value

                        // no default
                    };}
        }

        return null;
    },
    CallExpression: function CallExpression(node, initialScope) {
        var calleeNode = node.callee;
        var args = getElementValues(node.arguments, initialScope);

        if (args != null) {
            if (calleeNode.type === "MemberExpression") {
                var object = getStaticValueR(calleeNode.object, initialScope);
                var property = calleeNode.computed ? getStaticValueR(calleeNode.property, initialScope) : { value: calleeNode.property.name };

                if (object != null && property != null) {
                    var receiver = object.value;
                    var methodName = property.value;
                    return { value: receiver[methodName].apply(receiver, _toConsumableArray(args)) };
                }
            } else {
                var callee = getStaticValueR(calleeNode, initialScope);
                if (callee != null) {
                    var func = callee.value;
                    return { value: func.apply(undefined, _toConsumableArray(args)) };
                }
            }
        }

        return null;
    },
    ConditionalExpression: function ConditionalExpression(node, initialScope) {
        var test = getStaticValueR(node.test, initialScope);
        if (test != null) {
            return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
        }
        return null;
    },
    ExpressionStatement: function ExpressionStatement(node, initialScope) {
        return getStaticValueR(node.expression, initialScope);
    },
    Identifier: function Identifier(node, initialScope) {
        if (initialScope != null) {
            var variable = findVariable(initialScope, node);

            // Built-in globals.
            if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in global) {
                return { value: global[variable.name] };
            }

            // Constants.
            if (variable != null && variable.defs.length === 1) {
                var def = variable.defs[0];
                if (def.parent && def.parent.kind === "const" &&
                // TODO(mysticatea): don't support destructuring here.
                def.node.id.type === "Identifier") {
                    return getStaticValueR(def.node.init, initialScope);
                }
            }
        }
        return null;
    },
    Literal: function Literal(node) {
        //istanbul ignore if : this is implementation-specific behavior.
        if (node.regex != null && node.value == null) {
            // It was a RegExp literal, but Node.js didn't support it.
            return null;
        }
        return node;
    },
    LogicalExpression: function LogicalExpression(node, initialScope) {
        var left = getStaticValueR(node.left, initialScope);
        if (left != null) {
            if (node.operator === "||" && Boolean(left.value) === true || node.operator === "&&" && Boolean(left.value) === false) {
                return left;
            }

            var right = getStaticValueR(node.right, initialScope);
            if (right != null) {
                return right;
            }
        }

        return null;
    },
    MemberExpression: function MemberExpression(node, initialScope) {
        var object = getStaticValueR(node.object, initialScope);
        var property = node.computed ? getStaticValueR(node.property, initialScope) : { value: node.property.name };

        if (object != null && property != null) {
            return { value: object.value[property.value] };
        }
        return null;
    },
    NewExpression: function NewExpression(node, initialScope) {
        var callee = getStaticValueR(node.callee, initialScope);
        var args = getElementValues(node.arguments, initialScope);

        if (callee != null && args != null) {
            var Func = callee.value;
            return { value: new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))() };
        }

        return null;
    },
    ObjectExpression: function ObjectExpression(node, initialScope) {
        var object = {};

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var propertyNode = _step2.value;

                if (propertyNode.type === "Property") {
                    if (propertyNode.kind !== "init") {
                        return null;
                    }
                    var key = propertyNode.computed ? getStaticValueR(propertyNode.key, initialScope) : { value: propertyNode.key.name };
                    var value = getStaticValueR(propertyNode.value, initialScope);
                    if (key == null || value == null) {
                        return null;
                    }
                    object[key.value] = value.value;
                } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
                    var argument = getStaticValueR(propertyNode.argument, initialScope);
                    if (argument == null) {
                        return null;
                    }
                    Object.assign(object, argument.value);
                } else {
                    return null;
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        return { value: object };
    },
    SequenceExpression: function SequenceExpression(node, initialScope) {
        var last = node.expressions[node.expressions.length - 1];
        return getStaticValueR(last, initialScope);
    },
    TaggedTemplateExpression: function TaggedTemplateExpression(node, initialScope) {
        var tag = getStaticValueR(node.tag, initialScope);
        var expressions = getElementValues(node.quasi.expressions, initialScope);

        if (tag != null && expressions != null) {
            var func = tag.value;
            var strings = node.quasi.quasis.map(function (q) {
                return q.value.cooked;
            });
            strings.raw = node.quasi.quasis.map(function (q) {
                return q.value.raw;
            });

            return { value: func.apply(undefined, [strings].concat(_toConsumableArray(expressions))) };
        }

        return null;
    },
    TemplateLiteral: function TemplateLiteral(node, initialScope) {
        var expressions = getElementValues(node.expressions, initialScope);
        if (expressions != null) {
            var value = node.quasis[0].value.cooked;
            for (var i = 0; i < expressions.length; ++i) {
                value += expressions[i];
                value += node.quasis[i + 1].value.cooked;
            }
            return { value: value };
        }
        return null;
    },
    UnaryExpression: function UnaryExpression(node, initialScope) {
        if (node.operator === "delete") {
            // Not supported.
            return null;
        }
        if (node.operator === "void") {
            return { value: undefined };
        }

        var arg = getStaticValueR(node.argument, initialScope);
        if (arg != null) {
            switch (node.operator) {
                case "-":
                    return { value: -arg.value };
                case "+":
                    return { value: +arg.value //eslint-disable-line no-implicit-coercion
                    };case "!":
                    return { value: !arg.value };
                case "~":
                    return { value: ~arg.value };
                case "typeof":
                    return { value: _typeof(arg.value)

                        // no default
                    };}
        }

        return null;
    }
});

/**
 * Get the value of a given node if it's a static value.
 * @param {Node} node The node to get.
 * @param {Scope|undefined} initialScope The scope to start finding variable.
 * @returns {{value:any}|null} The static value of the node, or `null`.
 */
function getStaticValueR(node, initialScope) {
    if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
        return operations[node.type](node, initialScope);
    }
    return null;
}

/**
 * Get the value of a given node if it's a static value.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If this scope was given, this tries to resolve identifier references which are in the given node as much as possible.
 * @returns {{value:any}|null} The static value of the node, or `null`.
 */
function getStaticValue(node) {
    var initialScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    try {
        return getStaticValueR(node, initialScope);
    } catch (_error) {
        return null;
    }
}

/**
 * Get the value of a given node if it's a literal or a template literal.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is an Identifier node and this scope was given, this checks the variable of the identifier, and returns the value of it if the variable is a constant.
 * @returns {string|null} The value of the node, or `null`.
 */
function getStringIfConstant(node) {
    var initialScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    var evaluated = getStaticValue(node, initialScope);
    return evaluated && String(evaluated.value);
}

/**
 * Get the property name from a MemberExpression node or a Property node.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.
 * @returns {string|null} The property name of the node.
 */
function getPropertyName(node, initialScope) {
    switch (node.type) {
        case "MemberExpression":
            if (node.computed) {
                return getStringIfConstant(node.property, initialScope);
            }
            return node.property.name;

        case "Property":
        case "MethodDefinition":
            if (node.computed) {
                return getStringIfConstant(node.key, initialScope);
            }
            if (node.key.type === "Literal") {
                return String(node.key.value);
            }
            return node.key.name;

        // no default
    }

    return null;
}

/**
 * Get the name and kind of the given function node.
 * @param {ASTNode} node - The function node to get.
 * @returns {string} The name and kind of the function node.
 */
function getFunctionNameWithKind(node) {
    var parent = node.parent;
    var tokens = [];

    if (parent.type === "MethodDefinition" && parent.static) {
        tokens.push("static");
    }
    if (node.async) {
        tokens.push("async");
    }
    if (node.generator) {
        tokens.push("generator");
    }

    if (node.type === "ArrowFunctionExpression") {
        tokens.push("arrow", "function");
    } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
        if (parent.kind === "constructor") {
            return "constructor";
        }
        if (parent.kind === "get") {
            tokens.push("getter");
        } else if (parent.kind === "set") {
            tokens.push("setter");
        } else {
            tokens.push("method");
        }
    } else {
        tokens.push("function");
    }

    if (node.id) {
        tokens.push('\'' + node.id.name + '\'');
    } else {
        var name = getPropertyName(parent);

        if (name) {
            tokens.push('\'' + name + '\'');
        }
    }

    return tokens.join(" ");
}

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */

var placeholder = /\$(?:[$&`']|[1-9][0-9]?)/g;

/** @type {WeakMap<PatternMatcher, {pattern:RegExp,escaped:boolean}>} */
var internal = new WeakMap();

/**
 * Check whether a given character is escaped or not.
 * @param {string} str The string to check.
 * @param {number} index The location of the character to check.
 * @returns {boolean} `true` if the character is escaped.
 */
function isEscaped(str, index) {
    var escaped = false;
    for (var i = index - 1; i >= 0 && str.charCodeAt(i) === 0x5c; --i) {
        escaped = !escaped;
    }
    return escaped;
}

/**
 * Replace a given string by a given matcher.
 * @param {PatternMatcher} matcher The pattern matcher.
 * @param {string} str The string to be replaced.
 * @param {string} replacement The new substring to replace each matched part.
 * @returns {string} The replaced string.
 */
function replaceS(matcher, str, replacement) {
    var chunks = [];
    var index = 0;

    /** @type {RegExpExecArray} */
    var match = null;

    /**
     * @param {string} key The placeholder.
     * @returns {string} The replaced string.
     */
    function replacer(key) {
        switch (key) {
            case "$$":
                return "$";
            case "$&":
                return match[0];
            case "$`":
                return str.slice(0, match.index);
            case "$'":
                return str.slice(match.index + match[0].length);
            default:
                {
                    var i = key.slice(1);
                    if (i in match) {
                        return match[i];
                    }
                    return key;
                }
        }
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = matcher.execAll(str)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            match = _step3.value;

            chunks.push(str.slice(index, match.index));
            chunks.push(replacement.replace(placeholder, replacer));
            index = match.index + match[0].length;
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    chunks.push(str.slice(index));

    return chunks.join("");
}

//eslint-disable-next-line valid-jsdoc
/**
 * Replace a given string by a given matcher.
 * @param {PatternMatcher} matcher The pattern matcher.
 * @param {string} str The string to be replaced.
 * @param {(...strs[])=>string} replace The function to replace each matched part.
 * @returns {string} The replaced string.
 */
function replaceF(matcher, str, replace) {
    var chunks = [];
    var index = 0;

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = matcher.execAll(str)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var match = _step4.value;

            chunks.push(str.slice(index, match.index));
            chunks.push(String(replace.apply(undefined, _toConsumableArray(match).concat([match.index, match.input]))));
            index = match.index + match[0].length;
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    chunks.push(str.slice(index));

    return chunks.join("");
}

/**
 * The class to find patterns as considering escape sequences.
 */

var PatternMatcher = function () {
    /**
     * Initialize this matcher.
     * @param {RegExp} pattern The pattern to match.
     * @param {{escaped:boolean}} options The options.
     */
    function PatternMatcher(pattern) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$escaped = _ref.escaped,
            escaped = _ref$escaped === undefined ? false : _ref$escaped;

        _classCallCheck(this, PatternMatcher);

        if (!(pattern instanceof RegExp)) {
            throw new TypeError("'pattern' should be a RegExp instance.");
        }
        if (!pattern.flags.includes("g")) {
            throw new Error("'pattern' should contains 'g' flag.");
        }

        internal.set(this, {
            pattern: new RegExp(pattern.source, pattern.flags),
            escaped: Boolean(escaped)
        });
    }

    /**
     * Find the pattern in a given string.
     * @param {string} str The string to find.
     * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
     */


    _createClass(PatternMatcher, [{
        key: 'execAll',
        value: /*#__PURE__*/regeneratorRuntime.mark(function execAll(str) {
            var _internal$get, pattern, escaped, match, lastIndex;

            return regeneratorRuntime.wrap(function execAll$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            _internal$get = internal.get(this), pattern = _internal$get.pattern, escaped = _internal$get.escaped;
                            match = null;
                            lastIndex = 0;


                            pattern.lastIndex = 0;

                        case 4:
                            if (!((match = pattern.exec(str)) != null)) {
                                _context.next = 12;
                                break;
                            }

                            if (!(escaped || !isEscaped(str, match.index))) {
                                _context.next = 10;
                                break;
                            }

                            lastIndex = pattern.lastIndex;
                            _context.next = 9;
                            return match;

                        case 9:
                            pattern.lastIndex = lastIndex;

                        case 10:
                            _context.next = 4;
                            break;

                        case 12:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, execAll, this);
        })

        /**
         * Check whether the pattern is found in a given string.
         * @param {string} str The string to check.
         * @returns {boolean} `true` if the pattern was found in the string.
         */

    }, {
        key: 'test',
        value: function test(str) {
            var it = this.execAll(str);
            var ret = it.next();
            return !ret.done;
        }

        //eslint-disable-next-line valid-jsdoc
        /**
         * Replace a given string.
         * @param {string} str The string to be replaced.
         * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
         * @returns {string} The replaced string.
         */

    }, {
        key: Symbol.replace,
        value: function value(str, replacer) {
            return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
        }
    }]);

    return PatternMatcher;
}();

var SENTINEL_TYPE = /^(?:.+?Statement|.+?Declaration|(?:Array|ArrowFunction|Assignment|Call|Class|Function|Member|New|Object)Expression|AssignmentPattern|Program|VariableDeclarator)$/;
var IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/;
var has = Function.call.bind(Object.hasOwnProperty);

var READ = Symbol("read");
var CALL = Symbol("call");
var CONSTRUCT = Symbol("construct");
var ESM = Symbol("esm");

var requireCall = { require: _defineProperty({}, CALL, true) };

/**
 * Check whether a given variable is modified or not.
 * @param {Variable} variable The variable to check.
 * @returns {boolean} `true` if the variable is modified.
 */
function isModifiedGlobal(variable) {
    return variable == null || variable.defs.length !== 0 || variable.references.some(function (r) {
        return r.isWrite();
    });
}

/**
 * The reference tracker.
 */

var ReferenceTracker = function () {
    /**
     * Initialize this tracker.
     * @param {Scope} globalScope The global scope.
     * @param {object} [options] The options.
     * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
     * @param {string[]} [options.globalObjectNames=["global","self","window"]] The variable names for Global Object.
     */
    function ReferenceTracker(globalScope) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref2$mode = _ref2.mode,
            mode = _ref2$mode === undefined ? "strict" : _ref2$mode,
            _ref2$globalObjectNam = _ref2.globalObjectNames,
            globalObjectNames = _ref2$globalObjectNam === undefined ? ["global", "self", "window"] : _ref2$globalObjectNam;

        _classCallCheck(this, ReferenceTracker);

        this.variableStack = [];
        this.globalScope = globalScope;
        this.mode = mode;
        this.globalObjectNames = globalObjectNames.slice(0);
    }

    /**
     * Iterate the references of global variables.
     * @param {object} traceMap The trace map.
     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
     */


    _createClass(ReferenceTracker, [{
        key: 'iterateGlobalReferences',
        value: /*#__PURE__*/regeneratorRuntime.mark(function iterateGlobalReferences(traceMap) {
            var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, key, nextTraceMap, path, variable, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, _key;

            return regeneratorRuntime.wrap(function iterateGlobalReferences$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            _iteratorNormalCompletion5 = true;
                            _didIteratorError5 = false;
                            _iteratorError5 = undefined;
                            _context2.prev = 3;
                            _iterator5 = Object.keys(traceMap)[Symbol.iterator]();

                        case 5:
                            if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                                _context2.next = 16;
                                break;
                            }

                            key = _step5.value;
                            nextTraceMap = traceMap[key];
                            path = [key];
                            variable = this.globalScope.set.get(key);

                            if (!isModifiedGlobal(variable)) {
                                _context2.next = 12;
                                break;
                            }

                            return _context2.abrupt('continue', 13);

                        case 12:
                            return _context2.delegateYield(this._iterateVariableReferences(variable, path, nextTraceMap, true), 't0', 13);

                        case 13:
                            _iteratorNormalCompletion5 = true;
                            _context2.next = 5;
                            break;

                        case 16:
                            _context2.next = 22;
                            break;

                        case 18:
                            _context2.prev = 18;
                            _context2.t1 = _context2['catch'](3);
                            _didIteratorError5 = true;
                            _iteratorError5 = _context2.t1;

                        case 22:
                            _context2.prev = 22;
                            _context2.prev = 23;

                            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                _iterator5.return();
                            }

                        case 25:
                            _context2.prev = 25;

                            if (!_didIteratorError5) {
                                _context2.next = 28;
                                break;
                            }

                            throw _iteratorError5;

                        case 28:
                            return _context2.finish(25);

                        case 29:
                            return _context2.finish(22);

                        case 30:
                            _iteratorNormalCompletion6 = true;
                            _didIteratorError6 = false;
                            _iteratorError6 = undefined;
                            _context2.prev = 33;
                            _iterator6 = this.globalObjectNames[Symbol.iterator]();

                        case 35:
                            if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                                _context2.next = 45;
                                break;
                            }

                            _key = _step6.value;
                            path = [];
                            variable = this.globalScope.set.get(_key);

                            if (!isModifiedGlobal(variable)) {
                                _context2.next = 41;
                                break;
                            }

                            return _context2.abrupt('continue', 42);

                        case 41:
                            return _context2.delegateYield(this._iterateVariableReferences(variable, path, traceMap, false), 't2', 42);

                        case 42:
                            _iteratorNormalCompletion6 = true;
                            _context2.next = 35;
                            break;

                        case 45:
                            _context2.next = 51;
                            break;

                        case 47:
                            _context2.prev = 47;
                            _context2.t3 = _context2['catch'](33);
                            _didIteratorError6 = true;
                            _iteratorError6 = _context2.t3;

                        case 51:
                            _context2.prev = 51;
                            _context2.prev = 52;

                            if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                _iterator6.return();
                            }

                        case 54:
                            _context2.prev = 54;

                            if (!_didIteratorError6) {
                                _context2.next = 57;
                                break;
                            }

                            throw _iteratorError6;

                        case 57:
                            return _context2.finish(54);

                        case 58:
                            return _context2.finish(51);

                        case 59:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, iterateGlobalReferences, this, [[3, 18, 22, 30], [23,, 25, 29], [33, 47, 51, 59], [52,, 54, 58]]);
        })

        /**
         * Iterate the references of CommonJS modules.
         * @param {object} traceMap The trace map.
         * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
         */

    }, {
        key: 'iterateCjsReferences',
        value: /*#__PURE__*/regeneratorRuntime.mark(function iterateCjsReferences(traceMap) {
            var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _ref3, node, key, nextTraceMap, path;

            return regeneratorRuntime.wrap(function iterateCjsReferences$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            _iteratorNormalCompletion7 = true;
                            _didIteratorError7 = false;
                            _iteratorError7 = undefined;
                            _context3.prev = 3;
                            _iterator7 = this.iterateGlobalReferences(requireCall)[Symbol.iterator]();

                        case 5:
                            if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
                                _context3.next = 20;
                                break;
                            }

                            _ref3 = _step7.value;
                            node = _ref3.node;
                            key = getStringIfConstant(node.arguments[0]);

                            if (!(key == null || !has(traceMap, key))) {
                                _context3.next = 11;
                                break;
                            }

                            return _context3.abrupt('continue', 17);

                        case 11:
                            nextTraceMap = traceMap[key];
                            path = [key];

                            if (!nextTraceMap[READ]) {
                                _context3.next = 16;
                                break;
                            }

                            _context3.next = 16;
                            return {
                                node: node,
                                path: path,
                                type: READ,
                                info: nextTraceMap[READ]
                            };

                        case 16:
                            return _context3.delegateYield(this._iteratePropertyReferences(node, path, nextTraceMap), 't0', 17);

                        case 17:
                            _iteratorNormalCompletion7 = true;
                            _context3.next = 5;
                            break;

                        case 20:
                            _context3.next = 26;
                            break;

                        case 22:
                            _context3.prev = 22;
                            _context3.t1 = _context3['catch'](3);
                            _didIteratorError7 = true;
                            _iteratorError7 = _context3.t1;

                        case 26:
                            _context3.prev = 26;
                            _context3.prev = 27;

                            if (!_iteratorNormalCompletion7 && _iterator7.return) {
                                _iterator7.return();
                            }

                        case 29:
                            _context3.prev = 29;

                            if (!_didIteratorError7) {
                                _context3.next = 32;
                                break;
                            }

                            throw _iteratorError7;

                        case 32:
                            return _context3.finish(29);

                        case 33:
                            return _context3.finish(26);

                        case 34:
                        case 'end':
                            return _context3.stop();
                    }
                }
            }, iterateCjsReferences, this, [[3, 22, 26, 34], [27,, 29, 33]]);
        })

        /**
         * Iterate the references of ES modules.
         * @param {object} traceMap The trace map.
         * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
         */

    }, {
        key: 'iterateEsmReferences',
        value: /*#__PURE__*/regeneratorRuntime.mark(function iterateEsmReferences(traceMap) {
            var programNode, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, node, moduleId, nextTraceMap, path, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, key, exportTraceMap, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, specifier, esm, it, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, report;

            return regeneratorRuntime.wrap(function iterateEsmReferences$(_context4) {
                while (1) {
                    switch (_context4.prev = _context4.next) {
                        case 0:
                            programNode = this.globalScope.block;
                            _iteratorNormalCompletion8 = true;
                            _didIteratorError8 = false;
                            _iteratorError8 = undefined;
                            _context4.prev = 4;
                            _iterator8 = programNode.body[Symbol.iterator]();

                        case 6:
                            if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                                _context4.next = 110;
                                break;
                            }

                            node = _step8.value;

                            if (!(!IMPORT_TYPE.test(node.type) || node.source == null)) {
                                _context4.next = 10;
                                break;
                            }

                            return _context4.abrupt('continue', 107);

                        case 10:
                            moduleId = node.source.value;

                            if (has(traceMap, moduleId)) {
                                _context4.next = 13;
                                break;
                            }

                            return _context4.abrupt('continue', 107);

                        case 13:
                            nextTraceMap = traceMap[moduleId];
                            path = [moduleId];

                            if (!nextTraceMap[READ]) {
                                _context4.next = 18;
                                break;
                            }

                            _context4.next = 18;
                            return { node: node, path: path, type: READ, info: nextTraceMap[READ] };

                        case 18:
                            if (!(node.type === "ExportAllDeclaration")) {
                                _context4.next = 49;
                                break;
                            }

                            _iteratorNormalCompletion9 = true;
                            _didIteratorError9 = false;
                            _iteratorError9 = undefined;
                            _context4.prev = 22;
                            _iterator9 = Object.keys(nextTraceMap)[Symbol.iterator]();

                        case 24:
                            if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {
                                _context4.next = 33;
                                break;
                            }

                            key = _step9.value;
                            exportTraceMap = nextTraceMap[key];

                            if (!exportTraceMap[READ]) {
                                _context4.next = 30;
                                break;
                            }

                            _context4.next = 30;
                            return {
                                node: node,
                                path: path.concat(key),
                                type: READ,
                                info: exportTraceMap[READ]
                            };

                        case 30:
                            _iteratorNormalCompletion9 = true;
                            _context4.next = 24;
                            break;

                        case 33:
                            _context4.next = 39;
                            break;

                        case 35:
                            _context4.prev = 35;
                            _context4.t0 = _context4['catch'](22);
                            _didIteratorError9 = true;
                            _iteratorError9 = _context4.t0;

                        case 39:
                            _context4.prev = 39;
                            _context4.prev = 40;

                            if (!_iteratorNormalCompletion9 && _iterator9.return) {
                                _iterator9.return();
                            }

                        case 42:
                            _context4.prev = 42;

                            if (!_didIteratorError9) {
                                _context4.next = 45;
                                break;
                            }

                            throw _iteratorError9;

                        case 45:
                            return _context4.finish(42);

                        case 46:
                            return _context4.finish(39);

                        case 47:
                            _context4.next = 107;
                            break;

                        case 49:
                            _iteratorNormalCompletion10 = true;
                            _didIteratorError10 = false;
                            _iteratorError10 = undefined;
                            _context4.prev = 52;
                            _iterator10 = node.specifiers[Symbol.iterator]();

                        case 54:
                            if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
                                _context4.next = 93;
                                break;
                            }

                            specifier = _step10.value;
                            esm = has(nextTraceMap, ESM);
                            it = this._iterateImportReferences(specifier, path, esm ? nextTraceMap : this.mode === "legacy" ? Object.assign({ default: nextTraceMap }, nextTraceMap) : { default: nextTraceMap });

                            if (!esm) {
                                _context4.next = 62;
                                break;
                            }

                            return _context4.delegateYield(it, 't1', 60);

                        case 60:
                            _context4.next = 90;
                            break;

                        case 62:
                            _iteratorNormalCompletion11 = true;
                            _didIteratorError11 = false;
                            _iteratorError11 = undefined;
                            _context4.prev = 65;
                            _iterator11 = it[Symbol.iterator]();

                        case 67:
                            if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
                                _context4.next = 76;
                                break;
                            }

                            report = _step11.value;

                            report.path = report.path.filter(exceptDefault);

                            if (!(report.path.length >= 2 || report.type !== READ)) {
                                _context4.next = 73;
                                break;
                            }

                            _context4.next = 73;
                            return report;

                        case 73:
                            _iteratorNormalCompletion11 = true;
                            _context4.next = 67;
                            break;

                        case 76:
                            _context4.next = 82;
                            break;

                        case 78:
                            _context4.prev = 78;
                            _context4.t2 = _context4['catch'](65);
                            _didIteratorError11 = true;
                            _iteratorError11 = _context4.t2;

                        case 82:
                            _context4.prev = 82;
                            _context4.prev = 83;

                            if (!_iteratorNormalCompletion11 && _iterator11.return) {
                                _iterator11.return();
                            }

                        case 85:
                            _context4.prev = 85;

                            if (!_didIteratorError11) {
                                _context4.next = 88;
                                break;
                            }

                            throw _iteratorError11;

                        case 88:
                            return _context4.finish(85);

                        case 89:
                            return _context4.finish(82);

                        case 90:
                            _iteratorNormalCompletion10 = true;
                            _context4.next = 54;
                            break;

                        case 93:
                            _context4.next = 99;
                            break;

                        case 95:
                            _context4.prev = 95;
                            _context4.t3 = _context4['catch'](52);
                            _didIteratorError10 = true;
                            _iteratorError10 = _context4.t3;

                        case 99:
                            _context4.prev = 99;
                            _context4.prev = 100;

                            if (!_iteratorNormalCompletion10 && _iterator10.return) {
                                _iterator10.return();
                            }

                        case 102:
                            _context4.prev = 102;

                            if (!_didIteratorError10) {
                                _context4.next = 105;
                                break;
                            }

                            throw _iteratorError10;

                        case 105:
                            return _context4.finish(102);

                        case 106:
                            return _context4.finish(99);

                        case 107:
                            _iteratorNormalCompletion8 = true;
                            _context4.next = 6;
                            break;

                        case 110:
                            _context4.next = 116;
                            break;

                        case 112:
                            _context4.prev = 112;
                            _context4.t4 = _context4['catch'](4);
                            _didIteratorError8 = true;
                            _iteratorError8 = _context4.t4;

                        case 116:
                            _context4.prev = 116;
                            _context4.prev = 117;

                            if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                _iterator8.return();
                            }

                        case 119:
                            _context4.prev = 119;

                            if (!_didIteratorError8) {
                                _context4.next = 122;
                                break;
                            }

                            throw _iteratorError8;

                        case 122:
                            return _context4.finish(119);

                        case 123:
                            return _context4.finish(116);

                        case 124:
                        case 'end':
                            return _context4.stop();
                    }
                }
            }, iterateEsmReferences, this, [[4, 112, 116, 124], [22, 35, 39, 47], [40,, 42, 46], [52, 95, 99, 107], [65, 78, 82, 90], [83,, 85, 89], [100,, 102, 106], [117,, 119, 123]]);
        })

        /**
         * Iterate the references for a given variable.
         * @param {Variable} variable The variable to iterate that references.
         * @param {string[]} path The current path.
         * @param {object} traceMap The trace map.
         * @param {boolean} shouldReport = The flag to report those references.
         * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
         */

    }, {
        key: '_iterateVariableReferences',
        value: /*#__PURE__*/regeneratorRuntime.mark(function _iterateVariableReferences(variable, path, traceMap, shouldReport) {
            var _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, reference, node;

            return regeneratorRuntime.wrap(function _iterateVariableReferences$(_context5) {
                while (1) {
                    switch (_context5.prev = _context5.next) {
                        case 0:
                            if (!this.variableStack.includes(variable)) {
                                _context5.next = 2;
                                break;
                            }

                            return _context5.abrupt('return');

                        case 2:
                            this.variableStack.push(variable);
                            _context5.prev = 3;
                            _iteratorNormalCompletion12 = true;
                            _didIteratorError12 = false;
                            _iteratorError12 = undefined;
                            _context5.prev = 7;
                            _iterator12 = variable.references[Symbol.iterator]();

                        case 9:
                            if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
                                _context5.next = 21;
                                break;
                            }

                            reference = _step12.value;

                            if (reference.isRead()) {
                                _context5.next = 13;
                                break;
                            }

                            return _context5.abrupt('continue', 18);

                        case 13:
                            node = reference.identifier;

                            if (!(shouldReport && traceMap[READ])) {
                                _context5.next = 17;
                                break;
                            }

                            _context5.next = 17;
                            return { node: node, path: path, type: READ, info: traceMap[READ] };

                        case 17:
                            return _context5.delegateYield(this._iteratePropertyReferences(node, path, traceMap), 't0', 18);

                        case 18:
                            _iteratorNormalCompletion12 = true;
                            _context5.next = 9;
                            break;

                        case 21:
                            _context5.next = 27;
                            break;

                        case 23:
                            _context5.prev = 23;
                            _context5.t1 = _context5['catch'](7);
                            _didIteratorError12 = true;
                            _iteratorError12 = _context5.t1;

                        case 27:
                            _context5.prev = 27;
                            _context5.prev = 28;

                            if (!_iteratorNormalCompletion12 && _iterator12.return) {
                                _iterator12.return();
                            }

                        case 30:
                            _context5.prev = 30;

                            if (!_didIteratorError12) {
                                _context5.next = 33;
                                break;
                            }

                            throw _iteratorError12;

                        case 33:
                            return _context5.finish(30);

                        case 34:
                            return _context5.finish(27);

                        case 35:
                            _context5.prev = 35;

                            this.variableStack.pop();
                            return _context5.finish(35);

                        case 38:
                        case 'end':
                            return _context5.stop();
                    }
                }
            }, _iterateVariableReferences, this, [[3,, 35, 38], [7, 23, 27, 35], [28,, 30, 34]]);
        })

        /**
         * Iterate the references for a given AST node.
         * @param rootNode The AST node to iterate references.
         * @param {string[]} path The current path.
         * @param {object} traceMap The trace map.
         * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
         */
        //eslint-disable-next-line complexity, require-jsdoc

    }, {
        key: '_iteratePropertyReferences',
        value: /*#__PURE__*/regeneratorRuntime.mark(function _iteratePropertyReferences(rootNode, path, traceMap) {
            var node, parent, key, nextTraceMap;
            return regeneratorRuntime.wrap(function _iteratePropertyReferences$(_context6) {
                while (1) {
                    switch (_context6.prev = _context6.next) {
                        case 0:
                            node = rootNode;

                            while (!SENTINEL_TYPE.test(node.parent.type)) {
                                node = node.parent;
                            }

                            parent = node.parent;

                            if (!(parent.type === "MemberExpression")) {
                                _context6.next = 15;
                                break;
                            }

                            if (!(parent.object === node)) {
                                _context6.next = 14;
                                break;
                            }

                            key = getPropertyName(parent);

                            if (!(key == null || !has(traceMap, key))) {
                                _context6.next = 8;
                                break;
                            }

                            return _context6.abrupt('return');

                        case 8:

                            path = path.concat(key); //eslint-disable-line no-param-reassign
                            nextTraceMap = traceMap[key];

                            if (!nextTraceMap[READ]) {
                                _context6.next = 13;
                                break;
                            }

                            _context6.next = 13;
                            return {
                                node: parent,
                                path: path,
                                type: READ,
                                info: nextTraceMap[READ]
                            };

                        case 13:
                            return _context6.delegateYield(this._iteratePropertyReferences(parent, path, nextTraceMap), 't0', 14);

                        case 14:
                            return _context6.abrupt('return');

                        case 15:
                            if (!(parent.type === "CallExpression")) {
                                _context6.next = 20;
                                break;
                            }

                            if (!(parent.callee === node && traceMap[CALL])) {
                                _context6.next = 19;
                                break;
                            }

                            _context6.next = 19;
                            return { node: parent, path: path, type: CALL, info: traceMap[CALL] };

                        case 19:
                            return _context6.abrupt('return');

                        case 20:
                            if (!(parent.type === "NewExpression")) {
                                _context6.next = 25;
                                break;
                            }

                            if (!(parent.callee === node && traceMap[CONSTRUCT])) {
                                _context6.next = 24;
                                break;
                            }

                            _context6.next = 24;
                            return {
                                node: parent,
                                path: path,
                                type: CONSTRUCT,
                                info: traceMap[CONSTRUCT]
                            };

                        case 24:
                            return _context6.abrupt('return');

                        case 25:
                            if (!(parent.type === "AssignmentExpression")) {
                                _context6.next = 30;
                                break;
                            }

                            if (!(parent.right === node)) {
                                _context6.next = 29;
                                break;
                            }

                            return _context6.delegateYield(this._iterateLhsReferences(parent.left, path, traceMap), 't1', 28);

                        case 28:
                            return _context6.delegateYield(this._iteratePropertyReferences(parent, path, traceMap), 't2', 29);

                        case 29:
                            return _context6.abrupt('return');

                        case 30:
                            if (!(parent.type === "AssignmentPattern")) {
                                _context6.next = 34;
                                break;
                            }

                            if (!(parent.right === node)) {
                                _context6.next = 33;
                                break;
                            }

                            return _context6.delegateYield(this._iterateLhsReferences(parent.left, path, traceMap), 't3', 33);

                        case 33:
                            return _context6.abrupt('return');

                        case 34:
                            if (!(parent.type === "VariableDeclarator")) {
                                _context6.next = 37;
                                break;
                            }

                            if (!(parent.init === node)) {
                                _context6.next = 37;
                                break;
                            }

                            return _context6.delegateYield(this._iterateLhsReferences(parent.id, path, traceMap), 't4', 37);

                        case 37:
                        case 'end':
                            return _context6.stop();
                    }
                }
            }, _iteratePropertyReferences, this);
        })

        /**
         * Iterate the references for a given Pattern node.
         * @param {Node} patternNode The Pattern node to iterate references.
         * @param {string[]} path The current path.
         * @param {object} traceMap The trace map.
         * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
         */

    }, {
        key: '_iterateLhsReferences',
        value: /*#__PURE__*/regeneratorRuntime.mark(function _iterateLhsReferences(patternNode, path, traceMap) {
            var variable, _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, property, key, nextPath, nextTraceMap;

            return regeneratorRuntime.wrap(function _iterateLhsReferences$(_context7) {
                while (1) {
                    switch (_context7.prev = _context7.next) {
                        case 0:
                            if (!(patternNode.type === "Identifier")) {
                                _context7.next = 5;
                                break;
                            }

                            variable = findVariable(this.globalScope, patternNode);

                            if (!(variable != null)) {
                                _context7.next = 4;
                                break;
                            }

                            return _context7.delegateYield(this._iterateVariableReferences(variable, path, traceMap, false), 't0', 4);

                        case 4:
                            return _context7.abrupt('return');

                        case 5:
                            if (!(patternNode.type === "ObjectPattern")) {
                                _context7.next = 40;
                                break;
                            }

                            _iteratorNormalCompletion13 = true;
                            _didIteratorError13 = false;
                            _iteratorError13 = undefined;
                            _context7.prev = 9;
                            _iterator13 = patternNode.properties[Symbol.iterator]();

                        case 11:
                            if (_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done) {
                                _context7.next = 25;
                                break;
                            }

                            property = _step13.value;
                            key = getPropertyName(property);

                            if (!(key == null || !has(traceMap, key))) {
                                _context7.next = 16;
                                break;
                            }

                            return _context7.abrupt('continue', 22);

                        case 16:
                            nextPath = path.concat(key);
                            nextTraceMap = traceMap[key];

                            if (!nextTraceMap[READ]) {
                                _context7.next = 21;
                                break;
                            }

                            _context7.next = 21;
                            return {
                                node: property,
                                path: nextPath,
                                type: READ,
                                info: nextTraceMap[READ]
                            };

                        case 21:
                            return _context7.delegateYield(this._iterateLhsReferences(property.value, nextPath, nextTraceMap), 't1', 22);

                        case 22:
                            _iteratorNormalCompletion13 = true;
                            _context7.next = 11;
                            break;

                        case 25:
                            _context7.next = 31;
                            break;

                        case 27:
                            _context7.prev = 27;
                            _context7.t2 = _context7['catch'](9);
                            _didIteratorError13 = true;
                            _iteratorError13 = _context7.t2;

                        case 31:
                            _context7.prev = 31;
                            _context7.prev = 32;

                            if (!_iteratorNormalCompletion13 && _iterator13.return) {
                                _iterator13.return();
                            }

                        case 34:
                            _context7.prev = 34;

                            if (!_didIteratorError13) {
                                _context7.next = 37;
                                break;
                            }

                            throw _iteratorError13;

                        case 37:
                            return _context7.finish(34);

                        case 38:
                            return _context7.finish(31);

                        case 39:
                            return _context7.abrupt('return');

                        case 40:
                            if (!(patternNode.type === "AssignmentPattern")) {
                                _context7.next = 42;
                                break;
                            }

                            return _context7.delegateYield(this._iterateLhsReferences(patternNode.left, path, traceMap), 't3', 42);

                        case 42:
                        case 'end':
                            return _context7.stop();
                    }
                }
            }, _iterateLhsReferences, this, [[9, 27, 31, 39], [32,, 34, 38]]);
        })

        /**
         * Iterate the references for a given ModuleSpecifier node.
         * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
         * @param {string[]} path The current path.
         * @param {object} traceMap The trace map.
         * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
         */

    }, {
        key: '_iterateImportReferences',
        value: /*#__PURE__*/regeneratorRuntime.mark(function _iterateImportReferences(specifierNode, path, traceMap) {
            var type, key, nextTraceMap, _key2, _nextTraceMap;

            return regeneratorRuntime.wrap(function _iterateImportReferences$(_context8) {
                while (1) {
                    switch (_context8.prev = _context8.next) {
                        case 0:
                            type = specifierNode.type;

                            if (!(type === "ImportSpecifier" || type === "ImportDefaultSpecifier")) {
                                _context8.next = 12;
                                break;
                            }

                            key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;

                            if (has(traceMap, key)) {
                                _context8.next = 5;
                                break;
                            }

                            return _context8.abrupt('return');

                        case 5:

                            path = path.concat(key); //eslint-disable-line no-param-reassign
                            nextTraceMap = traceMap[key];

                            if (!nextTraceMap[READ]) {
                                _context8.next = 10;
                                break;
                            }

                            _context8.next = 10;
                            return {
                                node: specifierNode,
                                path: path,
                                type: READ,
                                info: nextTraceMap[READ]
                            };

                        case 10:
                            return _context8.delegateYield(this._iterateVariableReferences(findVariable(this.globalScope, specifierNode.local), path, nextTraceMap, false), 't0', 11);

                        case 11:
                            return _context8.abrupt('return');

                        case 12:
                            if (!(type === "ImportNamespaceSpecifier")) {
                                _context8.next = 15;
                                break;
                            }

                            return _context8.delegateYield(this._iterateVariableReferences(findVariable(this.globalScope, specifierNode.local), path, traceMap, false), 't1', 14);

                        case 14:
                            return _context8.abrupt('return');

                        case 15:
                            if (!(type === "ExportSpecifier")) {
                                _context8.next = 24;
                                break;
                            }

                            _key2 = specifierNode.local.name;

                            if (has(traceMap, _key2)) {
                                _context8.next = 19;
                                break;
                            }

                            return _context8.abrupt('return');

                        case 19:

                            path = path.concat(_key2); //eslint-disable-line no-param-reassign
                            _nextTraceMap = traceMap[_key2];

                            if (!_nextTraceMap[READ]) {
                                _context8.next = 24;
                                break;
                            }

                            _context8.next = 24;
                            return {
                                node: specifierNode,
                                path: path,
                                type: READ,
                                info: _nextTraceMap[READ]
                            };

                        case 24:
                        case 'end':
                            return _context8.stop();
                    }
                }
            }, _iterateImportReferences, this);
        })
    }]);

    return ReferenceTracker;
}();

ReferenceTracker.READ = READ;
ReferenceTracker.CALL = CALL;
ReferenceTracker.CONSTRUCT = CONSTRUCT;
ReferenceTracker.ESM = ESM;

/**
 * This is a predicate function for Array#filter.
 * @param {string} name A name part.
 * @param {number} index The index of the name.
 * @returns {boolean} `false` if it's default.
 */
function exceptDefault(name, index) {
    return !(index === 1 && name === "default");
}

var index = {
    CALL: CALL,
    CONSTRUCT: CONSTRUCT,
    ESM: ESM,
    findVariable: findVariable,
    getFunctionHeadLocation: getFunctionHeadLocation,
    getFunctionNameWithKind: getFunctionNameWithKind,
    getInnermostScope: getInnermostScope,
    getPropertyName: getPropertyName,
    getStaticValue: getStaticValue,
    getStringIfConstant: getStringIfConstant,
    isArrowToken: isArrowToken,
    isClosingBraceToken: isClosingBraceToken,
    isClosingBracketToken: isClosingBracketToken,
    isClosingParenToken: isClosingParenToken,
    isColonToken: isColonToken,
    isCommaToken: isCommaToken,
    isCommentToken: isCommentToken,
    isNotArrowToken: isNotArrowToken,
    isNotClosingBraceToken: isNotClosingBraceToken,
    isNotClosingBracketToken: isNotClosingBracketToken,
    isNotClosingParenToken: isNotClosingParenToken,
    isNotColonToken: isNotColonToken,
    isNotCommaToken: isNotCommaToken,
    isNotCommentToken: isNotCommentToken,
    isNotOpeningBraceToken: isNotOpeningBraceToken,
    isNotOpeningBracketToken: isNotOpeningBracketToken,
    isNotOpeningParenToken: isNotOpeningParenToken,
    isNotSemicolonToken: isNotSemicolonToken,
    isOpeningBraceToken: isOpeningBraceToken,
    isOpeningBracketToken: isOpeningBracketToken,
    isOpeningParenToken: isOpeningParenToken,
    isSemicolonToken: isSemicolonToken,
    PatternMatcher: PatternMatcher,
    READ: READ,
    ReferenceTracker: ReferenceTracker
};

exports.default = index;
exports.CALL = CALL;
exports.CONSTRUCT = CONSTRUCT;
exports.ESM = ESM;
exports.findVariable = findVariable;
exports.getFunctionHeadLocation = getFunctionHeadLocation;
exports.getFunctionNameWithKind = getFunctionNameWithKind;
exports.getInnermostScope = getInnermostScope;
exports.getPropertyName = getPropertyName;
exports.getStaticValue = getStaticValue;
exports.getStringIfConstant = getStringIfConstant;
exports.isArrowToken = isArrowToken;
exports.isClosingBraceToken = isClosingBraceToken;
exports.isClosingBracketToken = isClosingBracketToken;
exports.isClosingParenToken = isClosingParenToken;
exports.isColonToken = isColonToken;
exports.isCommaToken = isCommaToken;
exports.isCommentToken = isCommentToken;
exports.isNotArrowToken = isNotArrowToken;
exports.isNotClosingBraceToken = isNotClosingBraceToken;
exports.isNotClosingBracketToken = isNotClosingBracketToken;
exports.isNotClosingParenToken = isNotClosingParenToken;
exports.isNotColonToken = isNotColonToken;
exports.isNotCommaToken = isNotCommaToken;
exports.isNotCommentToken = isNotCommentToken;
exports.isNotOpeningBraceToken = isNotOpeningBraceToken;
exports.isNotOpeningBracketToken = isNotOpeningBracketToken;
exports.isNotOpeningParenToken = isNotOpeningParenToken;
exports.isNotSemicolonToken = isNotSemicolonToken;
exports.isOpeningBraceToken = isOpeningBraceToken;
exports.isOpeningBracketToken = isOpeningBracketToken;
exports.isOpeningParenToken = isOpeningParenToken;
exports.isSemicolonToken = isSemicolonToken;
exports.PatternMatcher = PatternMatcher;
exports.READ = READ;
exports.ReferenceTracker = ReferenceTracker;
//# sourceMappingURL=index.js.map