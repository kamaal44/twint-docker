'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _fs;

function _load_fs() {
  return _fs = _interopRequireDefault(require('fs'));
}

var _jestHasteMap;

function _load_jestHasteMap() {
  return _jestHasteMap = require('jest-haste-map');
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var FAIL = 0;
// $FlowFixMe: Missing ESM export
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var SUCCESS = 1;

var TestSequencer = function () {
  function TestSequencer() {
    _classCallCheck(this, TestSequencer);

    this._cache = new Map();
  }

  _createClass(TestSequencer, [{
    key: '_getCachePath',
    value: function _getCachePath(context) {
      var config = context.config;

      return (0, (_jestHasteMap || _load_jestHasteMap()).getCacheFilePath)(config.cacheDirectory, 'perf-cache-' + config.name);
    }
  }, {
    key: '_getCache',
    value: function _getCache(test) {
      var context = test.context;

      if (!this._cache.has(context) && context.config.cache) {
        var cachePath = this._getCachePath(context);
        if ((_fs || _load_fs()).default.existsSync(cachePath)) {
          try {
            this._cache.set(context, JSON.parse((_fs || _load_fs()).default.readFileSync(cachePath, 'utf8')));
          } catch (e) {}
        }
      }

      var cache = this._cache.get(context);
      if (!cache) {
        cache = {};
        this._cache.set(context, cache);
      }

      return cache;
    }

    // When running more tests than we have workers available, sort the tests
    // by size - big test files usually take longer to complete, so we run
    // them first in an effort to minimize worker idle time at the end of a
    // long test run.
    //
    // After a test run we store the time it took to run a test and on
    // subsequent runs we use that to run the slowest tests first, yielding the
    // fastest results.

  }, {
    key: 'sort',
    value: function sort(tests) {
      var _this = this;

      var stats = {};
      var fileSize = function fileSize(test) {
        return stats[test.path] || (stats[test.path] = (_fs || _load_fs()).default.statSync(test.path).size);
      };
      var hasFailed = function hasFailed(cache, test) {
        return cache[test.path] && cache[test.path][0] === FAIL;
      };
      var time = function time(cache, test) {
        return cache[test.path] && cache[test.path][1];
      };

      tests.forEach(function (test) {
        return test.duration = time(_this._getCache(test), test);
      });
      return tests.sort(function (testA, testB) {
        var cacheA = _this._getCache(testA);
        var cacheB = _this._getCache(testB);
        var failedA = hasFailed(cacheA, testA);
        var failedB = hasFailed(cacheB, testB);
        var hasTimeA = testA.duration != null;
        if (failedA !== failedB) {
          return failedA ? -1 : 1;
        } else if (hasTimeA != (testB.duration != null)) {
          // Check if only one of two tests has timing information
          return hasTimeA != null ? 1 : -1;
        } else if (testA.duration != null && testB.duration != null) {
          return testA.duration < testB.duration ? 1 : -1;
        } else {
          return fileSize(testA) < fileSize(testB) ? 1 : -1;
        }
      });
    }
  }, {
    key: 'cacheResults',
    value: function cacheResults(tests, results) {
      var _this2 = this;

      var map = Object.create(null);
      tests.forEach(function (test) {
        return map[test.path] = test;
      });
      results.testResults.forEach(function (testResult) {
        if (testResult && map[testResult.testFilePath] && !testResult.skipped) {
          var cache = _this2._getCache(map[testResult.testFilePath]);
          var perf = testResult.perfStats;
          cache[testResult.testFilePath] = [testResult.numFailingTests ? FAIL : SUCCESS, perf.end - perf.start || 0];
        }
      });

      this._cache.forEach(function (cache, context) {
        return (_fs || _load_fs()).default.writeFileSync(_this2._getCachePath(context), JSON.stringify(cache));
      });
    }
  }]);

  return TestSequencer;
}();

exports.default = TestSequencer;