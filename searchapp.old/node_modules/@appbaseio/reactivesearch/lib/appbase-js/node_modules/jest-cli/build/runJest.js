'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _micromatch;

function _load_micromatch() {
  return _micromatch = _interopRequireDefault(require('micromatch'));
}

var _chalk;

function _load_chalk() {
  return _chalk = _interopRequireDefault(require('chalk'));
}

var _path;

function _load_path() {
  return _path = _interopRequireDefault(require('path'));
}

var _jestUtil;

function _load_jestUtil() {
  return _jestUtil = require('jest-util');
}

var _exit;

function _load_exit() {
  return _exit = _interopRequireDefault(require('exit'));
}

var _gracefulFs;

function _load_gracefulFs() {
  return _gracefulFs = _interopRequireDefault(require('graceful-fs'));
}

var _getNoTestsFoundMessage;

function _load_getNoTestsFoundMessage() {
  return _getNoTestsFoundMessage = _interopRequireDefault(require('./getNoTestsFoundMessage'));
}

var _SearchSource;

function _load_SearchSource() {
  return _SearchSource = _interopRequireDefault(require('./SearchSource'));
}

var _TestScheduler;

function _load_TestScheduler() {
  return _TestScheduler = _interopRequireDefault(require('./TestScheduler'));
}

var _TestSequencer;

function _load_TestSequencer() {
  return _TestSequencer = _interopRequireDefault(require('./TestSequencer'));
}

var _testResultHelpers;

function _load_testResultHelpers() {
  return _testResultHelpers = require('./testResultHelpers');
}

var _FailedTestsCache;

function _load_FailedTestsCache() {
  return _FailedTestsCache = _interopRequireDefault(require('./FailedTestsCache'));
}

var _jestWatcher;

function _load_jestWatcher() {
  return _jestWatcher = require('jest-watcher');
}

var _collectHandles;

function _load_collectHandles() {
  return _collectHandles = _interopRequireDefault(require('./collectHandles'));
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _asyncToGenerator(fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step('next', value);
          }, function (err) {
            step('throw', err);
          });
        }
      }
      return step('next');
    });
  };
}
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var setConfig = function setConfig(contexts, newConfig) {
  return contexts.forEach(function (context) {
    return context.config = Object.freeze(Object.assign({}, context.config, newConfig));
  });
};

var getTestPaths = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(globalConfig, context, outputStream, changedFilesPromise, jestHooks) {
    var source, data, shouldTestArray, filteredTests;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            source = new (_SearchSource || _load_SearchSource()).default(context);
            _context.next = 3;
            return source.getTestPaths(globalConfig, changedFilesPromise);

          case 3:
            data = _context.sent;


            if (!data.tests.length && globalConfig.onlyChanged && data.noSCM) {
              new (_jestUtil || _load_jestUtil()).Console(outputStream, outputStream).log('Jest can only find uncommitted changed files in a git or hg ' + 'repository. If you make your project a git or hg ' + 'repository (`git init` or `hg init`), Jest will be able ' + 'to only run tests related to files changed since the last ' + 'commit.');
            }

            _context.next = 7;
            return Promise.all(data.tests.map(function (test) {
              return jestHooks.shouldRunTestSuite({
                config: test.context.config,
                duration: test.duration,
                testPath: test.path
              });
            }));

          case 7:
            shouldTestArray = _context.sent;
            filteredTests = data.tests.filter(function (test, i) {
              return shouldTestArray[i];
            });
            return _context.abrupt('return', Object.assign({}, data, {
              allTests: filteredTests.length,
              tests: filteredTests
            }));

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function getTestPaths(_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
}();

var processResults = function processResults(runResults, options) {
  var outputFile = options.outputFile,
      isJSON = options.isJSON,
      onComplete = options.onComplete,
      outputStream = options.outputStream,
      testResultsProcessor = options.testResultsProcessor,
      collectHandles = options.collectHandles;

  if (collectHandles) {
    runResults.openHandles = collectHandles();
  } else {
    runResults.openHandles = [];
  }

  if (testResultsProcessor) {
    /* $FlowFixMe */
    runResults = require(testResultsProcessor)(runResults);
  }
  if (isJSON) {
    if (outputFile) {
      var filePath = (_path || _load_path()).default.resolve(process.cwd(), outputFile);

      (_gracefulFs || _load_gracefulFs()).default.writeFileSync(filePath, JSON.stringify((0, (_jestUtil || _load_jestUtil()).formatTestResults)(runResults)));
      outputStream.write('Test results written to: ' + ((_path || _load_path()).default.relative(process.cwd(), filePath) + '\n'));
    } else {
      process.stdout.write(JSON.stringify((0, (_jestUtil || _load_jestUtil()).formatTestResults)(runResults)));
    }
  }

  return onComplete && onComplete(runResults);
};

var testSchedulerContext = {
  firstRun: true,
  previousSuccess: true
};

exports.default = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {
    var contexts, globalConfig, outputStream, testWatcher, _ref2$jestHooks, jestHooks, startRun, changedFilesPromise, onComplete, failedTestsCache, sequencer, allTests, _ref4, repos, noSCM, collectCoverageFrom, testRunData, newConfig, testsPaths, noTestsFoundMessage, _newConfig, collectHandles, globalSetup, results, globalTeardown;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            contexts = _ref2.contexts, globalConfig = _ref2.globalConfig, outputStream = _ref2.outputStream, testWatcher = _ref2.testWatcher;
            _ref2$jestHooks = _ref2.jestHooks;
            jestHooks = _ref2$jestHooks === undefined ? new (_jestWatcher || _load_jestWatcher()).JestHook().getEmitter() : _ref2$jestHooks, startRun = _ref2.startRun, changedFilesPromise = _ref2.changedFilesPromise, onComplete = _ref2.onComplete, failedTestsCache = _ref2.failedTestsCache;
            sequencer = new (_TestSequencer || _load_TestSequencer()).default();
            allTests = [];

            if (!(changedFilesPromise && globalConfig.watch)) {
              _context3.next = 12;
              break;
            }

            _context3.next = 8;
            return changedFilesPromise;

          case 8:
            _ref4 = _context3.sent;
            repos = _ref4.repos;
            noSCM = Object.keys(repos).every(function (scm) {
              return repos[scm].size === 0;
            });

            if (noSCM) {
              process.stderr.write('\n' + (_chalk || _load_chalk()).default.bold('--watch') + ' is not supported without git/hg, please use --watchAll ' + '\n');
              (0, (_exit || _load_exit()).default)(1);
            }

          case 12:
            collectCoverageFrom = [];
            _context3.next = 15;
            return Promise.all(contexts.map(function () {
              var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(context) {
                var matches;
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return getTestPaths(globalConfig, context, outputStream, changedFilesPromise, jestHooks);

                      case 2:
                        matches = _context2.sent;

                        allTests = allTests.concat(matches.tests);

                        if (matches.collectCoverageFrom) {
                          collectCoverageFrom = collectCoverageFrom.concat(matches.collectCoverageFrom.filter(function (filename) {
                            if (globalConfig.collectCoverageFrom && !(0, (_micromatch || _load_micromatch()).default)([(_path || _load_path()).default.relative(globalConfig.rootDir, filename)], globalConfig.collectCoverageFrom).length) {
                              return false;
                            }

                            if (globalConfig.coveragePathIgnorePatterns && globalConfig.coveragePathIgnorePatterns.some(function (pattern) {
                              return filename.match(pattern);
                            })) {
                              return false;
                            }

                            return true;
                          }));
                        }

                        return _context2.abrupt('return', { context: context, matches: matches });

                      case 6:
                      case 'end':
                        return _context2.stop();
                    }
                  }
                }, _callee2, this);
              }));

              return function (_x7) {
                return _ref5.apply(this, arguments);
              };
            }()));

          case 15:
            testRunData = _context3.sent;


            if (collectCoverageFrom.length) {
              // $FlowFixMe Object.assign
              newConfig = Object.assign({}, globalConfig, {
                collectCoverageFrom: collectCoverageFrom
              });

              globalConfig = Object.freeze(newConfig);
            }

            allTests = sequencer.sort(allTests);

            if (!globalConfig.listTests) {
              _context3.next = 23;
              break;
            }

            testsPaths = Array.from(new Set(allTests.map(function (test) {
              return test.path;
            })));

            if (globalConfig.json) {
              console.log(JSON.stringify(testsPaths));
            } else {
              console.log(testsPaths.join('\n'));
            }

            onComplete && onComplete((0, (_testResultHelpers || _load_testResultHelpers()).makeEmptyAggregatedTestResult)());
            return _context3.abrupt('return', null);

          case 23:

            if (globalConfig.onlyFailures && failedTestsCache) {
              allTests = failedTestsCache.filterTests(allTests);
              globalConfig = failedTestsCache.updateConfig(globalConfig);
            }

            if (!allTests.length) {
              noTestsFoundMessage = (0, (_getNoTestsFoundMessage || _load_getNoTestsFoundMessage()).default)(testRunData, globalConfig);


              if (globalConfig.passWithNoTests || globalConfig.findRelatedTests || globalConfig.lastCommit || globalConfig.onlyChanged) {
                new (_jestUtil || _load_jestUtil()).Console(outputStream, outputStream).log(noTestsFoundMessage);
              } else {
                new (_jestUtil || _load_jestUtil()).Console(outputStream, outputStream).error(noTestsFoundMessage);

                (0, (_exit || _load_exit()).default)(1);
              }
            } else if (allTests.length === 1 && globalConfig.silent !== true && globalConfig.verbose !== false) {
              // $FlowFixMe Object.assign
              _newConfig = Object.assign({}, globalConfig, {
                verbose: true
              });

              globalConfig = Object.freeze(_newConfig);
            }

            // When using more than one context, make all printed paths relative to the
            // current cwd. Do not modify rootDir, since will be used by custom resolvers.
            // If --runInBand is true, the resolver saved a copy during initialization,
            // however, if it is running on spawned processes, the initiation of the
            // custom resolvers is done within each spawned process and it needs the
            // original value of rootDir. Instead, use the {cwd: Path} property to resolve
            // paths when printing.
            setConfig(contexts, { cwd: process.cwd() });

            collectHandles = void 0;


            if (globalConfig.detectOpenHandles) {
              collectHandles = (0, (_collectHandles || _load_collectHandles()).default)();
            }

            if (!globalConfig.globalSetup) {
              _context3.next = 34;
              break;
            }

            // $FlowFixMe
            globalSetup = require(globalConfig.globalSetup);

            if (!(typeof globalSetup !== 'function')) {
              _context3.next = 32;
              break;
            }

            throw new TypeError('globalSetup file must export a function at ' + globalConfig.globalSetup);

          case 32:
            _context3.next = 34;
            return globalSetup(globalConfig);

          case 34:
            _context3.next = 36;
            return new (_TestScheduler || _load_TestScheduler()).default(globalConfig, {
              startRun: startRun
            }, testSchedulerContext).scheduleTests(allTests, testWatcher);

          case 36:
            results = _context3.sent;


            sequencer.cacheResults(allTests, results);

            if (!globalConfig.globalTeardown) {
              _context3.next = 44;
              break;
            }

            // $FlowFixMe
            globalTeardown = require(globalConfig.globalTeardown);

            if (!(typeof globalTeardown !== 'function')) {
              _context3.next = 42;
              break;
            }

            throw new TypeError('globalTeardown file must export a function at ' + globalConfig.globalTeardown);

          case 42:
            _context3.next = 44;
            return globalTeardown(globalConfig);

          case 44:
            return _context3.abrupt('return', processResults(results, {
              collectHandles: collectHandles,
              isJSON: globalConfig.json,
              onComplete: onComplete,
              outputFile: globalConfig.outputFile,
              outputStream: outputStream,
              testResultsProcessor: globalConfig.testResultsProcessor
            }));

          case 45:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  function runJest(_x6) {
    return _ref3.apply(this, arguments);
  }

  return runJest;
}();