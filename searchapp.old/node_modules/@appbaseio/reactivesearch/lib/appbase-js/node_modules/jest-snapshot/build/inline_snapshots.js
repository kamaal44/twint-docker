'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.saveInlineSnapshots = undefined;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _babelTypes = require('babel-types');

var _utils = require('./utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var saveInlineSnapshots = exports.saveInlineSnapshots = function (snapshots, prettier, babelTraverse) {
  if (!prettier) {
    throw new Error('Jest: Inline Snapshots requires Prettier.\n' + 'Please ensure "prettier" is installed in your project.');
  }

  // Custom parser API was added in 1.5.0
  if (_semver2.default.lt(prettier.version, '1.5.0')) {
    throw new Error('Jest: Inline Snapshots require prettier>=1.5.0.\n' + 'Please upgrade "prettier".');
  }

  var snapshotsByFile = groupSnapshotsByFile(snapshots);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(snapshotsByFile)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var sourceFilePath = _step.value;

      saveSnapshotsForFile(snapshotsByFile[sourceFilePath], sourceFilePath, prettier, babelTraverse);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var saveSnapshotsForFile = function saveSnapshotsForFile(snapshots, sourceFilePath, prettier, babelTraverse) {
  var sourceFile = _fs2.default.readFileSync(sourceFilePath, 'utf8');

  // Resolve project configuration.
  // For older versions of Prettier, do not load configuration.
  var config = prettier.resolveConfig ? prettier.resolveConfig.sync(sourceFilePath, {
    editorconfig: true
  }) : null;

  // Detect the parser for the test file.
  // For older versions of Prettier, fallback to a simple parser detection.
  var inferredParser = prettier.getFileInfo ? prettier.getFileInfo.sync(sourceFilePath).inferredParser : config && config.parser || simpleDetectParser(sourceFilePath);

  // Format the source code using the custom parser API.
  var newSourceFile = prettier.format(sourceFile, Object.assign({}, config, {
    filepath: sourceFilePath,
    parser: createParser(snapshots, inferredParser, babelTraverse)
  }));

  if (newSourceFile !== sourceFile) {
    _fs2.default.writeFileSync(sourceFilePath, newSourceFile);
  }
};

var groupSnapshotsBy = function groupSnapshotsBy(createKey) {
  return function (snapshots) {
    return snapshots.reduce(function (object, inlineSnapshot) {
      var key = createKey(inlineSnapshot);
      return Object.assign(object, _defineProperty({}, key, (object[key] || []).concat(inlineSnapshot)));
    }, {});
  };
};

var groupSnapshotsByFrame = groupSnapshotsBy(function (_ref) {
  var _ref$frame = _ref.frame;
  var line = _ref$frame.line,
      column = _ref$frame.column;
  return line + ':' + (column - 1);
});
var groupSnapshotsByFile = groupSnapshotsBy(function (_ref2) {
  var file = _ref2.frame.file;
  return file;
});

var createParser = function createParser(snapshots, inferredParser, babelTraverse) {
  return function (text, parsers, options) {
    // Workaround for https://github.com/prettier/prettier/issues/3150
    options.parser = inferredParser;

    var groupedSnapshots = groupSnapshotsByFrame(snapshots);
    var remainingSnapshots = new Set(snapshots.map(function (_ref3) {
      var snapshot = _ref3.snapshot;
      return snapshot;
    }));
    var ast = parsers[inferredParser](text);

    // Flow uses a 'Program' parent node, babel expects a 'File'.
    if (ast.type !== 'File') {
      ast = (0, _babelTypes.file)(ast, ast.comments, ast.tokens);
      delete ast.program.comments;
    }

    babelTraverse(ast, {
      CallExpression: function CallExpression(_ref4) {
        var _ref4$node = _ref4.node;
        var args = _ref4$node.arguments,
            callee = _ref4$node.callee;

        if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier') {
          return;
        }
        var _callee$property$loc$ = callee.property.loc.start;
        var line = _callee$property$loc$.line,
            column = _callee$property$loc$.column;

        var snapshotsForFrame = groupedSnapshots[line + ':' + column];
        if (!snapshotsForFrame) {
          return;
        }
        if (snapshotsForFrame.length > 1) {
          throw new Error('Jest: Multiple inline snapshots for the same call are not supported.');
        }
        var snapshotIndex = args.findIndex(function (_ref5) {
          var type = _ref5.type;
          return type === 'TemplateLiteral';
        });
        var values = snapshotsForFrame.map(function (_ref6) {
          var snapshot = _ref6.snapshot;

          remainingSnapshots.delete(snapshot);

          return (0, _babelTypes.templateLiteral)([(0, _babelTypes.templateElement)({
            raw: (0, _utils.escapeBacktickString)(snapshot)
          })], []);
        });
        var replacementNode = values[0];

        if (snapshotIndex > -1) {
          args[snapshotIndex] = replacementNode;
        } else {
          args.push(replacementNode);
        }
      }
    });

    if (remainingSnapshots.size) {
      throw new Error('Jest: Couldn\'t locate all inline snapshots.');
    }

    return ast;
  };
};

var simpleDetectParser = function simpleDetectParser(filePath) {
  var extname = _path2.default.extname(filePath);
  if (/tsx?$/.test(extname)) {
    return 'typescript';
  }
  return 'babylon';
};