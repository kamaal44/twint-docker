'use strict';

var stringWidth = require('string-width');
var stripAnsi = require('strip-ansi');

var ESCAPES = new Set(['\x1B', '\x9B']);

var END_CODE = 39;

var ESCAPE_CODES = new Map([[0, 0], [1, 22], [2, 22], [3, 23], [4, 24], [7, 27], [8, 28], [9, 29], [30, 39], [31, 39], [32, 39], [33, 39], [34, 39], [35, 39], [36, 39], [37, 39], [90, 39], [40, 49], [41, 49], [42, 49], [43, 49], [44, 49], [45, 49], [46, 49], [47, 49]]);

var wrapAnsi = function wrapAnsi(code) {
	return ESCAPES.values().next().value + '[' + code + 'm';
};

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
var wordLengths = function wordLengths(str) {
	return str.split(' ').map(function (s) {
		return stringWidth(s);
	});
};

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
var wrapWord = function wrapWord(rows, word, cols) {
	var arr = Array.from(word);

	var insideEscape = false;
	var visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = arr.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var item = _step.value;

			var i = item[0];
			var char = item[1];
			var charLength = stringWidth(char);

			if (visible + charLength <= cols) {
				rows[rows.length - 1] += char;
			} else {
				rows.push(char);
				visible = 0;
			}

			if (ESCAPES.has(char)) {
				insideEscape = true;
			} else if (insideEscape && char === 'm') {
				insideEscape = false;
				continue;
			}

			if (insideEscape) {
				continue;
			}

			visible += charLength;

			if (visible === cols && i < arr.length - 1) {
				rows.push('');
				visible = 0;
			}
		}

		// It's possible that the last row we copy over is only
		// ansi escape characters, handle this edge-case
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// The wrap-ansi module can be invoked
// in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more
// than cols characters
//
// 'soft' allows long words to expand past the column length
var exec = function exec(str, cols, opts) {
	var options = opts || {};

	if (str.trim() === '') {
		return options.trim === false ? str : str.trim();
	}

	var pre = '';
	var ret = '';
	var escapeCode = void 0;

	var lengths = wordLengths(str);
	var words = str.split(' ');
	var rows = [''];

	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = Array.from(words).entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var item = _step2.value;

			var i = item[0];
			var word = item[1];

			rows[rows.length - 1] = options.trim === false ? rows[rows.length - 1] : rows[rows.length - 1].trim();
			var rowLength = stringWidth(rows[rows.length - 1]);

			if (rowLength || word === '') {
				if (rowLength === cols && options.wordWrap === false) {
					// If we start with a new word but the current row length equals the length of the columns, add a new row
					rows.push('');
					rowLength = 0;
				}

				rows[rows.length - 1] += ' ';
				rowLength++;
			}

			// In 'hard' wrap mode, the length of a line is
			// never allowed to extend past 'cols'
			if (lengths[i] > cols && options.hard) {
				if (rowLength) {
					rows.push('');
				}
				wrapWord(rows, word, cols);
				continue;
			}

			if (rowLength + lengths[i] > cols && rowLength > 0) {
				if (options.wordWrap === false && rowLength < cols) {
					wrapWord(rows, word, cols);
					continue;
				}

				rows.push('');
			}

			if (rowLength + lengths[i] > cols && options.wordWrap === false) {
				wrapWord(rows, word, cols);
				continue;
			}

			rows[rows.length - 1] += word;
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	pre = rows.map(function (r) {
		return options.trim === false ? r : r.trim();
	}).join('\n');

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = Array.from(pre).entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var _item = _step3.value;

			var i = _item[0];
			var char = _item[1];

			ret += char;

			if (ESCAPES.has(char)) {
				var _code = parseFloat(/\d[^m]*/.exec(pre.slice(i, i + 4)));
				escapeCode = _code === END_CODE ? null : _code;
			}

			var code = ESCAPE_CODES.get(Number(escapeCode));

			if (escapeCode && code) {
				if (pre[i + 1] === '\n') {
					ret += wrapAnsi(code);
				} else if (char === '\n') {
					ret += wrapAnsi(escapeCode);
				}
			}
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	return ret;
};

// For each newline, invoke the method separately
module.exports = function (str, cols, opts) {
	return String(str).normalize().split('\n').map(function (line) {
		return exec(line, cols, opts);
	}).join('\n');
};