'use strict';

// Do a two-pass walk, first to get the list of packages that need to be
// bundled, then again to get the actual files and folders.
// Keep a cache of node_modules content and package.json data, so that the
// second walk doesn't have to re-do all the same work.

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var bundleWalk = require('npm-bundled');
var BundleWalker = bundleWalk.BundleWalker;
var BundleWalkerSync = bundleWalk.BundleWalkerSync;

var ignoreWalk = require('ignore-walk');
var IgnoreWalker = ignoreWalk.Walker;
var IgnoreWalkerSync = ignoreWalk.WalkerSync;

var rootBuiltinRules = Symbol('root-builtin-rules');
var packageNecessaryRules = Symbol('package-necessary-rules');
var path = require('path');

var defaultRules = ['.npmignore', '.gitignore', '**/.git', '**/.svn', '**/.hg', '**/CVS', '**/.git/**', '**/.svn/**', '**/.hg/**', '**/CVS/**', '/.lock-wscript', '/.wafpickle-*', '/build/config.gypi', 'npm-debug.log', '**/.npmrc', '.*.swp', '.DS_Store', '._*', '*.orig', 'package-lock.json', 'archived-packages/**'];

// a decorator that applies our custom rules to an ignore walker
var npmWalker = function npmWalker(Class) {
  return function (_Class) {
    _inherits(Walker, _Class);

    function Walker(opt) {
      _classCallCheck(this, Walker);

      opt = opt || {};

      // the order in which rules are applied.
      opt.ignoreFiles = [rootBuiltinRules, 'package.json', '.npmignore', '.gitignore', packageNecessaryRules];

      opt.includeEmpty = false;
      opt.path = opt.path || process.cwd();
      opt.follow = path.basename(opt.path) === 'node_modules';

      // ignore a bunch of things by default at the root level.
      // also ignore anything in node_modules, except bundled dependencies
      var _this = _possibleConstructorReturn(this, (Walker.__proto__ || Object.getPrototypeOf(Walker)).call(this, opt));

      if (!_this.parent) {
        _this.bundled = opt.bundled || [];
        _this.bundledScopes = Array.from(new Set(_this.bundled.filter(function (f) {
          return (/^@/.test(f)
          );
        }).map(function (f) {
          return f.split('/')[0];
        })));
        var rules = defaultRules.join('\n') + '\n';
        _this.packageJsonCache = opt.packageJsonCache || new Map();
        _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'onReadIgnoreFile', _this).call(_this, rootBuiltinRules, rules, function (_) {
          return _;
        });
      } else {
        _this.bundled = [];
        _this.bundledScopes = [];
        _this.packageJsonCache = _this.parent.packageJsonCache;
      }
      return _this;
    }

    _createClass(Walker, [{
      key: 'filterEntry',
      value: function filterEntry(entry, partial) {
        // get the partial path from the root of the walk
        var p = this.path.substr(this.root.length + 1);
        var pkgre = /^node_modules\/(@[^\/]+\/?[^\/]+|[^\/]+)(\/.*)?$/;
        var isRoot = !this.parent;
        var pkg = isRoot && pkgre.test(entry) ? entry.replace(pkgre, '$1') : null;
        var rootNM = isRoot && entry === 'node_modules';
        var rootPJ = isRoot && entry === 'package.json';

        return (
          // if we're in a bundled package, check with the parent.
          /^node_modules($|\/)/i.test(p) ? this.parent.filterEntry(this.basename + '/' + entry, partial)

          // if package is bundled, all files included
          // also include @scope dirs for bundled scoped deps
          // they'll be ignored if no files end up in them.
          // However, this only matters if we're in the root.
          // node_modules folders elsewhere, like lib/node_modules,
          // should be included normally unless ignored.
          : pkg ? -1 !== this.bundled.indexOf(pkg) || -1 !== this.bundledScopes.indexOf(pkg)

          // only walk top node_modules if we want to bundle something
          : rootNM ? !!this.bundled.length

          // always include package.json at the root.
          : rootPJ ? true

          // otherwise, follow ignore-walk's logic
          : _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'filterEntry', this).call(this, entry, partial)
        );
      }
    }, {
      key: 'filterEntries',
      value: function filterEntries() {
        if (this.ignoreRules['package.json']) this.ignoreRules['.gitignore'] = this.ignoreRules['.npmignore'] = null;else if (this.ignoreRules['.npmignore']) this.ignoreRules['.gitignore'] = null;
        this.filterEntries = _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'filterEntries', this);
        _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'filterEntries', this).call(this);
      }
    }, {
      key: 'addIgnoreFile',
      value: function addIgnoreFile(file, then) {
        var ig = path.resolve(this.path, file);
        if (this.packageJsonCache.has(ig)) this.onPackageJson(ig, this.packageJsonCache.get(ig), then);else _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'addIgnoreFile', this).call(this, file, then);
      }
    }, {
      key: 'onPackageJson',
      value: function onPackageJson(ig, pkg, then) {
        this.packageJsonCache.set(ig, pkg);

        // if there's a browser or main, make sure we don't ignore it
        var rules = [pkg.browser ? '!' + pkg.browser : '', pkg.main ? '!' + pkg.main : '', '!@(readme|copying|license|licence|notice|changes|changelog|history){,.*}'].filter(function (f) {
          return f;
        }).join('\n') + '\n';
        _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'onReadIgnoreFile', this).call(this, packageNecessaryRules, rules, function (_) {
          return _;
        });

        if (Array.isArray(pkg.files)) _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'onReadIgnoreFile', this).call(this, 'package.json', '*\n' + pkg.files.map(function (f) {
          return '!' + f + '\n!' + f.replace(/\/+$/, '') + '/**';
        }).join('\n') + '\n', then);else then();
      }

      // override parent onstat function to nix all symlinks

    }, {
      key: 'onstat',
      value: function onstat(st, entry, file, dir, then) {
        if (st.isSymbolicLink()) then();else _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'onstat', this).call(this, st, entry, file, dir, then);
      }
    }, {
      key: 'onReadIgnoreFile',
      value: function onReadIgnoreFile(file, data, then) {
        if (file === 'package.json') try {
          this.onPackageJson(file, JSON.parse(data), then);
        } catch (er) {
          // ignore package.json files that are not json
          then();
        } else _get(Walker.prototype.__proto__ || Object.getPrototypeOf(Walker.prototype), 'onReadIgnoreFile', this).call(this, file, data, then);
      }
    }, {
      key: 'sort',
      value: function sort(a, b) {
        return _sort(a, b);
      }
    }]);

    return Walker;
  }(Class);
};

var Walker = function (_npmWalker) {
  _inherits(Walker, _npmWalker);

  function Walker() {
    _classCallCheck(this, Walker);

    return _possibleConstructorReturn(this, (Walker.__proto__ || Object.getPrototypeOf(Walker)).apply(this, arguments));
  }

  _createClass(Walker, [{
    key: 'walker',
    value: function walker(entry, then) {
      new Walker(this.walkerOpt(entry)).on('done', then).start();
    }
  }]);

  return Walker;
}(npmWalker(IgnoreWalker));

var WalkerSync = function (_npmWalker2) {
  _inherits(WalkerSync, _npmWalker2);

  function WalkerSync() {
    _classCallCheck(this, WalkerSync);

    return _possibleConstructorReturn(this, (WalkerSync.__proto__ || Object.getPrototypeOf(WalkerSync)).apply(this, arguments));
  }

  _createClass(WalkerSync, [{
    key: 'walker',
    value: function walker(entry, then) {
      new WalkerSync(this.walkerOpt(entry)).start();
      then();
    }
  }]);

  return WalkerSync;
}(npmWalker(IgnoreWalkerSync));

var walk = function walk(options, callback) {
  options = options || {};
  var p = new Promise(function (resolve, reject) {
    var bw = new BundleWalker(options).start();
    bw.on('done', function (bundled) {
      options.bundled = bundled;
      options.packageJsonCache = bw.packageJsonCache;
      new Walker(options).on('done', resolve).on('error', reject).start();
    });
  });
  return callback ? p.then(function (res) {
    return callback(null, res);
  }, callback) : p;
};

var walkSync = function walkSync(options) {
  options = options || {};
  var bw = new BundleWalkerSync(options).start();
  options.bundled = bw.result;
  options.packageJsonCache = bw.packageJsonCache;
  var walker = new WalkerSync(options);
  walker.start();
  return walker.result;
};

// package.json first, node_modules last, files before folders, alphasort
var _sort = function _sort(a, b) {
  return a === 'package.json' ? -1 : b === 'package.json' ? 1 : /^node_modules/.test(a) && !/^node_modules/.test(b) ? 1 : /^node_modules/.test(b) && !/^node_modules/.test(a) ? -1 : path.dirname(a) === '.' && path.dirname(b) !== '.' ? -1 : path.dirname(b) === '.' && path.dirname(a) !== '.' ? 1 : a.localeCompare(b);
};

module.exports = walk;
walk.sync = walkSync;
walk.Walker = Walker;
walk.WalkerSync = WalkerSync;