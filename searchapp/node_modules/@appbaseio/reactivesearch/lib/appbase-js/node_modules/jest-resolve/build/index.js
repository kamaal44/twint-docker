'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _fs;

function _load_fs() {
  return _fs = _interopRequireDefault(require('fs'));
}

var _path;

function _load_path() {
  return _path = _interopRequireDefault(require('path'));
}

var _node_modules_paths;

function _load_node_modules_paths() {
  return _node_modules_paths = _interopRequireDefault(require('./node_modules_paths'));
}

var _is_builtin_module;

function _load_is_builtin_module() {
  return _is_builtin_module = _interopRequireDefault(require('./is_builtin_module'));
}

var _default_resolver;

function _load_default_resolver() {
  return _default_resolver = _interopRequireDefault(require('./default_resolver.js'));
}

var _chalk;

function _load_chalk() {
  return _chalk = _interopRequireDefault(require('chalk'));
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }return arr2;
  } else {
    return Array.from(arr);
  }
}
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var NATIVE_PLATFORM = 'native';

// We might be inside a symlink.
var cwd = process.cwd();
var resolvedCwd = (_fs || _load_fs()).default.realpathSync(cwd) || cwd;
var nodePaths = process.env.NODE_PATH ? process.env.NODE_PATH.split((_path || _load_path()).default.delimiter).filter(Boolean)
// The resolver expects absolute paths.
.map(function (p) {
  return (_path || _load_path()).default.resolve(resolvedCwd, p);
}) : null;

var Resolver = function () {
  function Resolver(moduleMap, options) {
    _classCallCheck(this, Resolver);

    this._options = {
      browser: options.browser,
      defaultPlatform: options.defaultPlatform,
      extensions: options.extensions,
      hasCoreModules: options.hasCoreModules === undefined ? true : options.hasCoreModules,
      moduleDirectories: options.moduleDirectories || ['node_modules'],
      moduleNameMapper: options.moduleNameMapper,
      modulePaths: options.modulePaths,
      platforms: options.platforms,
      resolver: options.resolver,
      rootDir: options.rootDir
    };
    this._moduleMap = moduleMap;
    this._moduleIDCache = Object.create(null);
    this._moduleNameCache = Object.create(null);
    this._modulePathCache = Object.create(null);
  }

  _createClass(Resolver, [{
    key: 'resolveModuleFromDirIfExists',
    value: function resolveModuleFromDirIfExists(dirname, moduleName, options) {
      var _this = this;

      var paths = options && options.paths || this._options.modulePaths;
      var moduleDirectory = this._options.moduleDirectories;
      var key = dirname + (_path || _load_path()).default.delimiter + moduleName;
      var defaultPlatform = this._options.defaultPlatform;
      var extensions = this._options.extensions.slice();
      if (this._supportsNativePlatform()) {
        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {
          return '.' + NATIVE_PLATFORM + ext;
        })));
      }
      if (defaultPlatform) {
        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {
          return '.' + defaultPlatform + ext;
        })));
      }

      // 0. If we have already resolved this module for this directory name,
      //    return a value from the cache.
      if (this._moduleNameCache[key]) {
        return this._moduleNameCache[key];
      }

      // 1. Check if the module is a haste module.
      var module = this.getModule(moduleName);
      if (module) {
        return this._moduleNameCache[key] = module;
      }

      // 2. Check if the module is a node module and resolve it based on
      //    the node module resolution algorithm.
      // If skipNodeResolution is given we ignore all modules that look like
      // node modules (ie. are not relative requires). This enables us to speed
      // up resolution when we build a dependency graph because we don't have
      // to look at modules that may not exist and aren't mocked.
      var skipResolution = options && options.skipNodeResolution && !moduleName.includes((_path || _load_path()).default.sep);

      var resolveNodeModule = function resolveNodeModule(name) {
        return Resolver.findNodeModule(name, {
          basedir: dirname,
          browser: _this._options.browser,
          extensions: extensions,
          moduleDirectory: moduleDirectory,
          paths: paths,
          resolver: _this._options.resolver,
          rootDir: _this._options.rootDir
        });
      };

      if (!skipResolution) {
        module = resolveNodeModule(moduleName);

        if (module) {
          return this._moduleNameCache[key] = module;
        }
      }

      // 3. Resolve "haste packages" which are `package.json` files outside of
      // `node_modules` folders anywhere in the file system.
      var parts = moduleName.split('/');
      var hastePackage = this.getPackage(parts.shift());
      if (hastePackage) {
        try {
          var _module = (_path || _load_path()).default.join.apply((_path || _load_path()).default, [(_path || _load_path()).default.dirname(hastePackage)].concat(parts));
          // try resolving with custom resolver first to support extensions,
          // then fallback to require.resolve
          return this._moduleNameCache[key] = resolveNodeModule(_module) || require.resolve(_module);
        } catch (ignoredError) {}
      }

      return null;
    }
  }, {
    key: 'resolveModule',
    value: function resolveModule(from, moduleName, options) {
      var dirname = (_path || _load_path()).default.dirname(from);
      var module = this.resolveModuleFromDirIfExists(dirname, moduleName, options);
      if (module) return module;

      // (4.) Throw an error if the module could not be found. `resolve.sync`
      //      only produces an error based on the dirname but we have the actual
      //      current module name available.
      var relativePath = (_path || _load_path()).default.relative(dirname, from);
      var err = new Error('Cannot find module \'' + moduleName + '\' from \'' + (relativePath || '.') + '\'');
      err.code = 'MODULE_NOT_FOUND';
      throw err;
    }
  }, {
    key: 'isCoreModule',
    value: function isCoreModule(moduleName) {
      return this._options.hasCoreModules && (0, (_is_builtin_module || _load_is_builtin_module()).default)(moduleName);
    }
  }, {
    key: 'getModule',
    value: function getModule(name) {
      return this._moduleMap.getModule(name, this._options.defaultPlatform, this._supportsNativePlatform());
    }
  }, {
    key: 'getModulePath',
    value: function getModulePath(from, moduleName) {
      if (moduleName[0] !== '.' || (_path || _load_path()).default.isAbsolute(moduleName)) {
        return moduleName;
      }
      return (_path || _load_path()).default.normalize((_path || _load_path()).default.dirname(from) + '/' + moduleName);
    }
  }, {
    key: 'getPackage',
    value: function getPackage(name) {
      return this._moduleMap.getPackage(name, this._options.defaultPlatform, this._supportsNativePlatform());
    }
  }, {
    key: 'getMockModule',
    value: function getMockModule(from, name) {
      var mock = this._moduleMap.getMockModule(name);
      if (mock) {
        return mock;
      } else {
        var moduleName = this._resolveStubModuleName(from, name);
        if (moduleName) {
          return this.getModule(moduleName) || moduleName;
        }
      }
      return null;
    }
  }, {
    key: 'getModulePaths',
    value: function getModulePaths(from) {
      if (!this._modulePathCache[from]) {
        var moduleDirectory = this._options.moduleDirectories;
        var paths = (0, (_node_modules_paths || _load_node_modules_paths()).default)(from, {
          moduleDirectory: moduleDirectory
        });
        if (paths[paths.length - 1] === undefined) {
          // circumvent node-resolve bug that adds `undefined` as last item.
          paths.pop();
        }
        this._modulePathCache[from] = paths;
      }
      return this._modulePathCache[from];
    }
  }, {
    key: 'getModuleID',
    value: function getModuleID(virtualMocks, from, _moduleName) {
      var moduleName = _moduleName || '';

      var key = from + (_path || _load_path()).default.delimiter + moduleName;
      if (this._moduleIDCache[key]) {
        return this._moduleIDCache[key];
      }

      var moduleType = this._getModuleType(moduleName);
      var absolutePath = this._getAbsolutePath(virtualMocks, from, moduleName);
      var mockPath = this._getMockPath(from, moduleName);

      var sep = (_path || _load_path()).default.delimiter;
      var id = moduleType + sep + (absolutePath ? absolutePath + sep : '') + (mockPath ? mockPath + sep : '');

      return this._moduleIDCache[key] = id;
    }
  }, {
    key: '_getModuleType',
    value: function _getModuleType(moduleName) {
      return this.isCoreModule(moduleName) ? 'node' : 'user';
    }
  }, {
    key: '_getAbsolutePath',
    value: function _getAbsolutePath(virtualMocks, from, moduleName) {
      if (this.isCoreModule(moduleName)) {
        return moduleName;
      }
      return this._isModuleResolved(from, moduleName) ? this.getModule(moduleName) : this._getVirtualMockPath(virtualMocks, from, moduleName);
    }
  }, {
    key: '_getMockPath',
    value: function _getMockPath(from, moduleName) {
      return !this.isCoreModule(moduleName) ? this.getMockModule(from, moduleName) : null;
    }
  }, {
    key: '_getVirtualMockPath',
    value: function _getVirtualMockPath(virtualMocks, from, moduleName) {
      var virtualMockPath = this.getModulePath(from, moduleName);
      return virtualMocks[virtualMockPath] ? virtualMockPath : moduleName ? this.resolveModule(from, moduleName) : from;
    }
  }, {
    key: '_isModuleResolved',
    value: function _isModuleResolved(from, moduleName) {
      return !!(this.getModule(moduleName) || this.getMockModule(from, moduleName));
    }
  }, {
    key: '_resolveStubModuleName',
    value: function _resolveStubModuleName(from, moduleName) {
      var _this2 = this;

      var dirname = (_path || _load_path()).default.dirname(from);
      var paths = this._options.modulePaths;
      var extensions = this._options.extensions;
      var moduleDirectory = this._options.moduleDirectories;
      var moduleNameMapper = this._options.moduleNameMapper;
      var resolver = this._options.resolver;

      if (moduleNameMapper) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = moduleNameMapper[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ref = _step.value;

            var mappedModuleName = _ref.moduleName;
            var regex = _ref.regex;

            if (regex.test(moduleName)) {
              var _ret = function () {
                // Note: once a moduleNameMapper matches the name, it must result
                // in a module, or else an error is thrown.
                var matches = moduleName.match(regex);
                var updatedName = matches ? mappedModuleName.replace(/\$([0-9]+)/g, function (_, index) {
                  return matches[parseInt(index, 10)];
                }) : mappedModuleName;

                var module = _this2.getModule(updatedName) || Resolver.findNodeModule(updatedName, {
                  basedir: dirname,
                  browser: _this2._options.browser,
                  extensions: extensions,
                  moduleDirectory: moduleDirectory,
                  paths: paths,
                  resolver: resolver,
                  rootDir: _this2._options.rootDir
                });
                if (!module) {
                  throw createNoMappedModuleFoundError(moduleName, updatedName, mappedModuleName, regex, resolver);
                }
                return {
                  v: module
                };
              }();

              if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return null;
    }
  }, {
    key: '_supportsNativePlatform',
    value: function _supportsNativePlatform() {
      return (this._options.platforms || []).indexOf(NATIVE_PLATFORM) !== -1;
    }
  }], [{
    key: 'findNodeModule',
    value: function findNodeModule(path, options) {
      var resolver = options.resolver /* $FlowFixMe */
      ? require(options.resolver) : (_default_resolver || _load_default_resolver()).default;
      var paths = options.paths;

      try {
        return resolver(path, {
          basedir: options.basedir,
          browser: options.browser,
          extensions: options.extensions,
          moduleDirectory: options.moduleDirectory,
          paths: paths ? (nodePaths || []).concat(paths) : nodePaths,
          rootDir: options.rootDir
        });
      } catch (e) {}
      return null;
    }
  }]);

  return Resolver;
}();

var createNoMappedModuleFoundError = function createNoMappedModuleFoundError(moduleName, updatedName, mappedModuleName, regex, resolver) {
  var error = new Error((_chalk || _load_chalk()).default.red((_chalk || _load_chalk()).default.bold('Configuration error') + ':\n\nCould not locate module ' + (_chalk || _load_chalk()).default.bold(moduleName) + ' mapped as:\n' + (_chalk || _load_chalk()).default.bold(updatedName) + '.\n\nPlease check your configuration for these entries:\n{\n  "moduleNameMapper": {\n    "' + regex.toString() + '": "' + (_chalk || _load_chalk()).default.bold(mappedModuleName) + '"\n  },\n  "resolver": ' + (_chalk || _load_chalk()).default.bold(String(resolver)) + '\n}'));

  error.name = '';

  return error;
};

module.exports = Resolver;