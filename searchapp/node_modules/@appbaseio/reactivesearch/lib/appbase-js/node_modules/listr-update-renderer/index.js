'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logUpdate = require('log-update');
var chalk = require('chalk');
var figures = require('figures');
var indentString = require('indent-string');
var cliTruncate = require('cli-truncate');
var stripAnsi = require('strip-ansi');
var utils = require('./lib/utils');

var renderHelper = function renderHelper(tasks, options, level) {
	level = level || 0;

	var output = [];

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = tasks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var task = _step.value;

			if (task.isEnabled()) {
				var skipped = task.isSkipped() ? ' ' + chalk.dim('[skipped]') : '';

				output.push(indentString(' ' + utils.getSymbol(task, options) + ' ' + task.title + skipped, level, '  '));

				if ((task.isPending() || task.isSkipped() || task.hasFailed()) && utils.isDefined(task.output)) {
					var data = task.output;

					if (typeof data === 'string') {
						data = stripAnsi(data.trim().split('\n').filter(Boolean).pop());

						if (data === '') {
							data = undefined;
						}
					}

					if (utils.isDefined(data)) {
						var out = indentString(figures.arrowRight + ' ' + data, level, '  ');
						output.push('   ' + chalk.gray(cliTruncate(out, process.stdout.columns - 3)));
					}
				}

				if ((task.isPending() || task.hasFailed() || options.collapse === false) && (task.hasFailed() || options.showSubtasks !== false) && task.subtasks.length > 0) {
					output = output.concat(renderHelper(task.subtasks, options, level + 1));
				}
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return output.join('\n');
};

var _render = function _render(tasks, options) {
	logUpdate(renderHelper(tasks, options));
};

var UpdateRenderer = function () {
	function UpdateRenderer(tasks, options) {
		_classCallCheck(this, UpdateRenderer);

		this._tasks = tasks;
		this._options = Object.assign({
			showSubtasks: true,
			collapse: true,
			clearOutput: false
		}, options);
	}

	_createClass(UpdateRenderer, [{
		key: 'render',
		value: function render() {
			var _this = this;

			if (this._id) {
				// Do not render if we are already rendering
				return;
			}

			this._id = setInterval(function () {
				_render(_this._tasks, _this._options);
			}, 100);
		}
	}, {
		key: 'end',
		value: function end(err) {
			if (this._id) {
				clearInterval(this._id);
				this._id = undefined;
			}

			_render(this._tasks, this._options);

			if (this._options.clearOutput && err === undefined) {
				logUpdate.clear();
			} else {
				logUpdate.done();
			}
		}
	}]);

	return UpdateRenderer;
}();

module.exports = UpdateRenderer;