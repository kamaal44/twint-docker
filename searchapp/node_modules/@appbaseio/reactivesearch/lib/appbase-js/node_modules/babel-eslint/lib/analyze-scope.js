"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var t = require("@babel/types");
var escope = require("eslint-scope");
var Definition = require("eslint-scope/lib/definition").Definition;
var OriginalPatternVisitor = require("eslint-scope/lib/pattern-visitor");
var OriginalReferencer = require("eslint-scope/lib/referencer");
var fallback = require("eslint-visitor-keys").getKeys;
var childVisitorKeys = require("./visitor-keys");

var flowFlippedAliasKeys = t.FLIPPED_ALIAS_KEYS.Flow.concat(["ArrayPattern", "ClassDeclaration", "ClassExpression", "FunctionDeclaration", "FunctionExpression", "Identifier", "ObjectPattern", "RestElement"]);
var visitorKeysMap = Object.keys(t.VISITOR_KEYS).reduce(function (acc, key) {
  var value = t.VISITOR_KEYS[key];
  if (flowFlippedAliasKeys.indexOf(value) === -1) {
    acc[key] = value;
  }
  return acc;
}, {});

var propertyTypes = {
  // loops
  callProperties: { type: "loop", values: ["value"] },
  indexers: { type: "loop", values: ["key", "value"] },
  properties: { type: "loop", values: ["argument", "value"] },
  types: { type: "loop" },
  params: { type: "loop" },
  // single property
  argument: { type: "single" },
  elementType: { type: "single" },
  qualification: { type: "single" },
  rest: { type: "single" },
  returnType: { type: "single" },
  // others
  typeAnnotation: { type: "typeAnnotation" },
  typeParameters: { type: "typeParameters" },
  id: { type: "id" }
};

var PatternVisitor = function (_OriginalPatternVisit) {
  _inherits(PatternVisitor, _OriginalPatternVisit);

  function PatternVisitor() {
    _classCallCheck(this, PatternVisitor);

    return _possibleConstructorReturn(this, (PatternVisitor.__proto__ || Object.getPrototypeOf(PatternVisitor)).apply(this, arguments));
  }

  _createClass(PatternVisitor, [{
    key: "ArrayPattern",
    value: function ArrayPattern(node) {
      node.elements.forEach(this.visit, this);
    }
  }, {
    key: "ObjectPattern",
    value: function ObjectPattern(node) {
      node.properties.forEach(this.visit, this);
    }
  }]);

  return PatternVisitor;
}(OriginalPatternVisitor);

var Referencer = function (_OriginalReferencer) {
  _inherits(Referencer, _OriginalReferencer);

  function Referencer() {
    _classCallCheck(this, Referencer);

    return _possibleConstructorReturn(this, (Referencer.__proto__ || Object.getPrototypeOf(Referencer)).apply(this, arguments));
  }

  _createClass(Referencer, [{
    key: "visitPattern",

    // inherits.
    value: function visitPattern(node, options, callback) {
      if (!node) {
        return;
      }

      // Visit type annotations.
      this._checkIdentifierOrVisit(node.typeAnnotation);
      if (t.isAssignmentPattern(node)) {
        this._checkIdentifierOrVisit(node.left.typeAnnotation);
      }

      // Overwrite `super.visitPattern(node, options, callback)` in order to not visit `ArrayPattern#typeAnnotation` and `ObjectPattern#typeAnnotation`.
      if (typeof options === "function") {
        callback = options;
        options = { processRightHandNodes: false };
      }

      var visitor = new PatternVisitor(this.options, node, callback);
      visitor.visit(node);

      // Process the right hand nodes recursively.
      if (options.processRightHandNodes) {
        visitor.rightHandNodes.forEach(this.visit, this);
      }
    }

    // inherits.

  }, {
    key: "visitClass",
    value: function visitClass(node) {
      // Decorators.
      this._visitArray(node.decorators);

      // Flow type parameters.
      var typeParamScope = this._nestTypeParamScope(node);

      // Flow super types.
      this._visitTypeAnnotation(node.implements);
      this._visitTypeAnnotation(node.superTypeParameters && node.superTypeParameters.params);

      // Basic.
      _get(Referencer.prototype.__proto__ || Object.getPrototypeOf(Referencer.prototype), "visitClass", this).call(this, node);

      // Close the type parameter scope.
      if (typeParamScope) {
        this.close(node);
      }
    }

    // inherits.

  }, {
    key: "visitFunction",
    value: function visitFunction(node) {
      var typeParamScope = this._nestTypeParamScope(node);

      // Flow return types.
      this._checkIdentifierOrVisit(node.returnType);

      // Basic.
      _get(Referencer.prototype.__proto__ || Object.getPrototypeOf(Referencer.prototype), "visitFunction", this).call(this, node);

      // Close the type parameter scope.
      if (typeParamScope) {
        this.close(node);
      }
    }

    // inherits.

  }, {
    key: "visitProperty",
    value: function visitProperty(node) {
      if (node.value && node.value.type === "TypeCastExpression") {
        this._visitTypeAnnotation(node.value);
      }
      this._visitArray(node.decorators);
      _get(Referencer.prototype.__proto__ || Object.getPrototypeOf(Referencer.prototype), "visitProperty", this).call(this, node);
    }
  }, {
    key: "InterfaceDeclaration",
    value: function InterfaceDeclaration(node) {
      this._createScopeVariable(node, node.id);

      var typeParamScope = this._nestTypeParamScope(node);

      // TODO: Handle mixins
      this._visitArray(node.extends);
      this.visit(node.body);

      if (typeParamScope) {
        this.close(node);
      }
    }
  }, {
    key: "TypeAlias",
    value: function TypeAlias(node) {
      this._createScopeVariable(node, node.id);

      var typeParamScope = this._nestTypeParamScope(node);

      this.visit(node.right);

      if (typeParamScope) {
        this.close(node);
      }
    }
  }, {
    key: "ClassProperty",
    value: function ClassProperty(node) {
      this._visitClassProperty(node);
    }
  }, {
    key: "ClassPrivateProperty",
    value: function ClassPrivateProperty(node) {
      this._visitClassProperty(node);
    }
  }, {
    key: "DeclareModule",
    value: function DeclareModule(node) {
      this._visitDeclareX(node);
    }
  }, {
    key: "DeclareFunction",
    value: function DeclareFunction(node) {
      this._visitDeclareX(node);
    }
  }, {
    key: "DeclareVariable",
    value: function DeclareVariable(node) {
      this._visitDeclareX(node);
    }
  }, {
    key: "DeclareClass",
    value: function DeclareClass(node) {
      this._visitDeclareX(node);
    }

    // visit OptionalMemberExpression as a MemberExpression.

  }, {
    key: "OptionalMemberExpression",
    value: function OptionalMemberExpression(node) {
      _get(Referencer.prototype.__proto__ || Object.getPrototypeOf(Referencer.prototype), "MemberExpression", this).call(this, node);
    }
  }, {
    key: "_visitClassProperty",
    value: function _visitClassProperty(node) {
      this._visitTypeAnnotation(node.typeAnnotation);
      this.visitProperty(node);
    }
  }, {
    key: "_visitDeclareX",
    value: function _visitDeclareX(node) {
      if (node.id) {
        this._createScopeVariable(node, node.id);
      }

      var typeParamScope = this._nestTypeParamScope(node);
      if (typeParamScope) {
        this.close(node);
      }
    }
  }, {
    key: "_createScopeVariable",
    value: function _createScopeVariable(node, name) {
      this.currentScope().variableScope.__define(name, new Definition("Variable", name, node, null, null, null));
    }
  }, {
    key: "_nestTypeParamScope",
    value: function _nestTypeParamScope(node) {
      if (!node.typeParameters) {
        return null;
      }

      var parentScope = this.scopeManager.__currentScope;
      var scope = new escope.Scope(this.scopeManager, "type-parameters", parentScope, node, false);

      this.scopeManager.__nestScope(scope);
      for (var j = 0; j < node.typeParameters.params.length; j++) {
        var name = node.typeParameters.params[j];
        scope.__define(name, new Definition("TypeParameter", name, name));
        if (name.typeAnnotation) {
          this._checkIdentifierOrVisit(name);
        }
      }
      scope.__define = function () {
        return parentScope.__define.apply(parentScope, arguments);
      };

      return scope;
    }
  }, {
    key: "_visitTypeAnnotation",
    value: function _visitTypeAnnotation(node) {
      if (!node) {
        return;
      }
      if (Array.isArray(node)) {
        node.forEach(this._visitTypeAnnotation, this);
        return;
      }

      // get property to check (params, id, etc...)
      var visitorValues = visitorKeysMap[node.type];
      if (!visitorValues) {
        return;
      }

      // can have multiple properties
      for (var i = 0; i < visitorValues.length; i++) {
        var visitorValue = visitorValues[i];
        var propertyType = propertyTypes[visitorValue];
        var nodeProperty = node[visitorValue];
        // check if property or type is defined
        if (propertyType == null || nodeProperty == null) {
          continue;
        }
        if (propertyType.type === "loop") {
          for (var j = 0; j < nodeProperty.length; j++) {
            if (Array.isArray(propertyType.values)) {
              for (var k = 0; k < propertyType.values.length; k++) {
                var loopPropertyNode = nodeProperty[j][propertyType.values[k]];
                if (loopPropertyNode) {
                  this._checkIdentifierOrVisit(loopPropertyNode);
                }
              }
            } else {
              this._checkIdentifierOrVisit(nodeProperty[j]);
            }
          }
        } else if (propertyType.type === "single") {
          this._checkIdentifierOrVisit(nodeProperty);
        } else if (propertyType.type === "typeAnnotation") {
          this._visitTypeAnnotation(node.typeAnnotation);
        } else if (propertyType.type === "typeParameters") {
          for (var l = 0; l < node.typeParameters.params.length; l++) {
            this._checkIdentifierOrVisit(node.typeParameters.params[l]);
          }
        } else if (propertyType.type === "id") {
          if (node.id.type === "Identifier") {
            this._checkIdentifierOrVisit(node.id);
          } else {
            this._visitTypeAnnotation(node.id);
          }
        }
      }
    }
  }, {
    key: "_checkIdentifierOrVisit",
    value: function _checkIdentifierOrVisit(node) {
      if (node && node.typeAnnotation) {
        this._visitTypeAnnotation(node.typeAnnotation);
      } else if (node && node.type === "Identifier") {
        this.visit(node);
      } else {
        this._visitTypeAnnotation(node);
      }
    }
  }, {
    key: "_visitArray",
    value: function _visitArray(nodeList) {
      if (nodeList) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nodeList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            this.visit(node);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }]);

  return Referencer;
}(OriginalReferencer);

module.exports = function (ast, parserOptions) {
  var options = {
    ignoreEval: true,
    optimistic: false,
    directive: false,
    nodejsScope: ast.sourceType === "script" && (parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) === true,
    impliedStrict: false,
    sourceType: ast.sourceType,
    ecmaVersion: parserOptions.ecmaVersion || 2018,
    fallback: fallback
  };

  if (OriginalReferencer._babelEslintPatched) {
    require("./patch-eslint-scope")(parserOptions);
    return escope.analyze(ast, options);
  }

  options.childVisitorKeys = childVisitorKeys;

  var scopeManager = new escope.ScopeManager(options);
  var referencer = new Referencer(options, scopeManager);

  referencer.visit(ast);

  return scopeManager;
};