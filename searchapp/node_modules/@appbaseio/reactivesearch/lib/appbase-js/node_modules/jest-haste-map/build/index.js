'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _child_process;

function _load_child_process() {
  return _child_process = require('child_process');
}

var _package;

function _load_package() {
  return _package = require('../package.json');
}

var _worker;

function _load_worker() {
  return _worker = require('./worker');
}

var _crypto;

function _load_crypto() {
  return _crypto = _interopRequireDefault(require('crypto'));
}

var _events;

function _load_events() {
  return _events = _interopRequireDefault(require('events'));
}

var _fs;

function _load_fs() {
  return _fs = _interopRequireDefault(require('fs'));
}

var _get_mock_name;

function _load_get_mock_name() {
  return _get_mock_name = _interopRequireDefault(require('./get_mock_name'));
}

var _get_platform_extension;

function _load_get_platform_extension() {
  return _get_platform_extension = _interopRequireDefault(require('./lib/get_platform_extension'));
}

var _constants;

function _load_constants() {
  return _constants = _interopRequireDefault(require('./constants'));
}

var _haste_fs;

function _load_haste_fs() {
  return _haste_fs = _interopRequireDefault(require('./haste_fs'));
}

var _module_map;

function _load_module_map() {
  return _module_map = _interopRequireDefault(require('./module_map'));
}

var _invariant;

function _load_invariant() {
  return _invariant = _interopRequireDefault(require('invariant'));
}

var _node;

function _load_node() {
  return _node = _interopRequireDefault(require('./crawlers/node'));
}

var _normalize_path_sep;

function _load_normalize_path_sep() {
  return _normalize_path_sep = _interopRequireDefault(require('./lib/normalize_path_sep'));
}

var _os;

function _load_os() {
  return _os = _interopRequireDefault(require('os'));
}

var _path;

function _load_path() {
  return _path = _interopRequireDefault(require('path'));
}

var _sane;

function _load_sane() {
  return _sane = _interopRequireDefault(require('sane'));
}

var _jestSerializer;

function _load_jestSerializer() {
  return _jestSerializer = _interopRequireDefault(require('jest-serializer'));
}

var _watchman;

function _load_watchman() {
  return _watchman = _interopRequireDefault(require('./crawlers/watchman'));
}

var _watchman_watcher;

function _load_watchman_watcher() {
  return _watchman_watcher = _interopRequireDefault(require('./lib/watchman_watcher'));
}

var _jestWorker;

function _load_jestWorker() {
  return _jestWorker = _interopRequireDefault(require('jest-worker'));
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var CHANGE_INTERVAL = 30;
// eslint-disable-next-line import/default

// eslint-disable-next-line import/default
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var MAX_WAIT_TIME = 240000;
var NODE_MODULES = (_path || _load_path()).default.sep + 'node_modules' + (_path || _load_path()).default.sep;

var canUseWatchman = function () {
  try {
    (0, (_child_process || _load_child_process()).execSync)('watchman --version', { stdio: ['ignore'] });
    return true;
  } catch (e) {}
  return false;
}();

var escapePathSeparator = function escapePathSeparator(string) {
  return (_path || _load_path()).default.sep === '\\' ? string.replace(/(\/|\\)/g, '\\\\') : string;
};

var getWhiteList = function getWhiteList(list) {
  if (list && list.length) {
    return new RegExp('(' + escapePathSeparator(NODE_MODULES) + '(?:' + list.join('|') + ')(?=$|' + escapePathSeparator((_path || _load_path()).default.sep) + '))', 'g');
  }
  return null;
};

/**
 * HasteMap is a JavaScript implementation of Facebook's haste module system.
 *
 * This implementation is inspired by https://github.com/facebook/node-haste
 * and was built with for high-performance in large code repositories with
 * hundreds of thousands of files. This implementation is scalable and provides
 * predictable performance.
 *
 * Because the haste map creation and synchronization is critical to startup
 * performance and most tasks are blocked by I/O this class makes heavy use of
 * synchronous operations. It uses worker processes for parallelizing file
 * access and metadata extraction.
 *
 * The data structures created by `jest-haste-map` can be used directly from the
 * cache without further processing. The metadata objects in the `files` and
 * `map` objects contain cross-references: a metadata object from one can look
 * up the corresponding metadata object in the other map. Note that in most
 * projects, the number of files will be greater than the number of haste
 * modules one module can refer to many files based on platform extensions.
 *
 * type HasteMap = {
 *   clocks: WatchmanClocks,
 *   files: {[filepath: string]: FileMetaData},
 *   map: {[id: string]: ModuleMapItem},
 *   mocks: {[id: string]: string},
 * }
 *
 * // Watchman clocks are used for query synchronization and file system deltas.
 * type WatchmanClocks = {[filepath: string]: string};
 *
 * type FileMetaData = {
 *   id: ?string, // used to look up module metadata objects in `map`.
 *   mtime: number, // check for outdated files.
 *   visited: boolean, // whether the file has been parsed or not.
 *   dependencies: Array<string>, // all relative dependencies of this file.
 *   sha1: ?string, // SHA-1 of the file, if requested via options.
 * };
 *
 * // Modules can be targeted to a specific platform based on the file name.
 * // Example: platform.ios.js and Platform.android.js will both map to the same
 * // `Platform` module. The platform should be specified during resolution.
 * type ModuleMapItem = {[platform: string]: ModuleMetaData};
 *
 * //
 * type ModuleMetaData = {
 *   path: string, // the path to look up the file object in `files`.
 *   type: string, // the module type (either `package` or `module`).
 * };
 *
 * Note that the data structures described above are conceptual only. The actual
 * implementation uses arrays and constant keys for metadata storage. Instead of
 * `{id: 'flatMap', mtime: 3421, visited: true, dependencies: []}` the real
 * representation is similar to `['flatMap', 3421, 1, []]` to save storage space
 * and reduce parse and write time of a big JSON blob.
 *
 * The HasteMap is created as follows:
 *  1. read data from the cache or create an empty structure.
 *
 *  2. crawl the file system.
 *     * empty cache: crawl the entire file system.
 *     * cache available:
 *       * if watchman is available: get file system delta changes.
 *       * if watchman is unavailable: crawl the entire file system.
 *     * build metadata objects for every file. This builds the `files` part of
 *       the `HasteMap`.
 *
 *  3. parse and extract metadata from changed files.
 *     * this is done in parallel over worker processes to improve performance.
 *     * the worst case is to parse all files.
 *     * the best case is no file system access and retrieving all data from
 *       the cache.
 *     * the average case is a small number of changed files.
 *
 *  4. serialize the new `HasteMap` in a cache file.
 *     Worker processes can directly access the cache through `HasteMap.read()`.
 *
 */

var HasteMap = function (_default) {
  _inherits(HasteMap, _default);

  function HasteMap(options) {
    _classCallCheck(this, HasteMap);

    var _this = _possibleConstructorReturn(this, (HasteMap.__proto__ || Object.getPrototypeOf(HasteMap)).call(this));

    _this._options = {
      cacheDirectory: options.cacheDirectory || (_os || _load_os()).default.tmpdir(),
      computeDependencies: options.computeDependencies === undefined ? true : options.computeDependencies,
      computeSha1: options.computeSha1 || false,
      extensions: options.extensions,
      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,
      hasteImplModulePath: options.hasteImplModulePath,
      ignorePattern: options.ignorePattern,
      maxWorkers: options.maxWorkers,
      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,
      name: options.name,
      platforms: options.platforms,
      resetCache: options.resetCache,
      retainAllFiles: options.retainAllFiles,
      roots: Array.from(new Set(options.roots)),
      throwOnModuleCollision: !!options.throwOnModuleCollision,
      useWatchman: options.useWatchman == null ? true : options.useWatchman,
      watch: !!options.watch
    };
    _this._console = options.console || global.console;
    if (!(options.ignorePattern instanceof RegExp)) {
      _this._console.warn('jest-haste-map: the `ignorePattern` options as a function is being ' + 'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.');
    }
    _this._cachePath = HasteMap.getCacheFilePath(_this._options.cacheDirectory, 'haste-map-' + _this._options.name, (_package || _load_package()).version, _this._options.roots.join(':'), _this._options.extensions.join(':'), _this._options.platforms.join(':'), _this._options.computeSha1.toString(), options.mocksPattern || '', options.ignorePattern.toString());
    _this._whitelist = getWhiteList(options.providesModuleNodeModules);
    _this._buildPromise = null;
    _this._watchers = [];
    _this._worker = null;
    return _this;
  }

  _createClass(HasteMap, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      if (!this._buildPromise) {
        this._buildPromise = this._buildFileMap().then(function (data) {
          return _this2._buildHasteMap(data);
        }).then(function (hasteMap) {
          _this2._persist(hasteMap);
          var hasteFS = new (_haste_fs || _load_haste_fs()).default(hasteMap.files);
          var moduleMap = new (_module_map || _load_module_map()).default({
            duplicates: hasteMap.duplicates,
            map: hasteMap.map,
            mocks: hasteMap.mocks
          });
          var __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;
          return _this2._watch(hasteMap, hasteFS, moduleMap).then(function () {
            return {
              __hasteMapForTest: __hasteMapForTest,
              hasteFS: hasteFS,
              moduleMap: moduleMap
            };
          });
        });
      }
      return this._buildPromise;
    }

    /**
     * 1. read data from the cache or create an empty structure.
     */

  }, {
    key: 'read',
    value: function read() {
      var hasteMap = void 0;

      try {
        hasteMap = (_jestSerializer || _load_jestSerializer()).default.readFileSync(this._cachePath);
      } catch (err) {
        hasteMap = this._createEmptyMap();
      }

      for (var key in hasteMap) {
        Object.setPrototypeOf(hasteMap[key], null);
      }

      return hasteMap;
    }
  }, {
    key: 'readModuleMap',
    value: function readModuleMap() {
      var data = this.read();
      return new (_module_map || _load_module_map()).default({
        duplicates: data.duplicates,
        map: data.map,
        mocks: data.mocks
      });
    }

    /**
     * 2. crawl the file system.
     */

  }, {
    key: '_buildFileMap',
    value: function _buildFileMap() {
      var _this3 = this;

      var read = this._options.resetCache ? this._createEmptyMap : this.read;

      return Promise.resolve().then(function () {
        return read.call(_this3);
      }).catch(function () {
        return _this3._createEmptyMap();
      }).then(function (cachedHasteMap) {
        var cachedFiles = Object.keys(cachedHasteMap.files).map(function (filePath) {
          var moduleName = cachedHasteMap.files[filePath][(_constants || _load_constants()).default.ID];
          return { moduleName: moduleName, path: filePath };
        });
        return _this3._crawl(cachedHasteMap).then(function (hasteMap) {
          var deprecatedFiles = cachedFiles.filter(function (file) {
            var fileData = hasteMap.files[file.path];
            return fileData == null || file.moduleName !== fileData[(_constants || _load_constants()).default.ID];
          });
          return { deprecatedFiles: deprecatedFiles, hasteMap: hasteMap };
        });
      });
    }

    /**
     * 3. parse and extract metadata from changed files.
     */

  }, {
    key: '_processFile',
    value: function _processFile(hasteMap, map, mocks, filePath, workerOptions) {
      var _this4 = this;

      var setModule = function setModule(id, module) {
        if (!map[id]) {
          // $FlowFixMe
          map[id] = Object.create(null);
        }
        var moduleMap = map[id];
        var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(module[(_constants || _load_constants()).default.PATH], _this4._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;

        var existingModule = moduleMap[platform];
        if (existingModule && existingModule[(_constants || _load_constants()).default.PATH] !== module[(_constants || _load_constants()).default.PATH]) {
          var message = 'jest-haste-map: @providesModule naming collision:\n' + ('  Duplicate module name: ' + id + '\n') + ('  Paths: ' + module[(_constants || _load_constants()).default.PATH] + ' collides with ') + (existingModule[(_constants || _load_constants()).default.PATH] + '\n\nThis ') + ((_this4._options.throwOnModuleCollision ? 'error' : 'warning') + ' ') + 'is caused by a @providesModule declaration ' + 'with the same name across two different files.';
          if (_this4._options.throwOnModuleCollision) {
            throw new Error(message);
          }
          _this4._console.warn(message);
          // We do NOT want consumers to use a module that is ambiguous.
          delete moduleMap[platform];
          if (Object.keys(moduleMap).length === 1) {
            delete map[id];
          }
          var _dupsByPlatform = hasteMap.duplicates[id];
          if (_dupsByPlatform == null) {
            _dupsByPlatform = hasteMap.duplicates[id] = Object.create(null);
          }
          var dups = _dupsByPlatform[platform] = Object.create(null);
          dups[module[(_constants || _load_constants()).default.PATH]] = module[(_constants || _load_constants()).default.TYPE];
          dups[existingModule[(_constants || _load_constants()).default.PATH]] = existingModule[(_constants || _load_constants()).default.TYPE];
          return;
        }

        var dupsByPlatform = hasteMap.duplicates[id];
        if (dupsByPlatform != null) {
          var _dups = dupsByPlatform[platform];
          if (_dups != null) {
            _dups[module[(_constants || _load_constants()).default.PATH]] = module[(_constants || _load_constants()).default.TYPE];
          }
          return;
        }

        moduleMap[platform] = module;
      };

      var fileMetadata = hasteMap.files[filePath];
      var moduleMetadata = hasteMap.map[fileMetadata[(_constants || _load_constants()).default.ID]];
      var computeSha1 = this._options.computeSha1 && !fileMetadata[(_constants || _load_constants()).default.SHA1];

      // Callback called when the response from the worker is successful.
      var workerReply = function workerReply(metadata) {
        // `1` for truthy values instead of `true` to save cache space.
        fileMetadata[(_constants || _load_constants()).default.VISITED] = 1;

        var metadataId = metadata.id;
        var metadataModule = metadata.module;

        if (metadataId && metadataModule) {
          fileMetadata[(_constants || _load_constants()).default.ID] = metadataId;
          setModule(metadataId, metadataModule);
        }

        fileMetadata[(_constants || _load_constants()).default.DEPENDENCIES] = metadata.dependencies || [];

        if (computeSha1) {
          fileMetadata[(_constants || _load_constants()).default.SHA1] = metadata.sha1;
        }
      };

      // Callback called when the response from the worker is an error.
      var workerError = function workerError(error) {
        if ((typeof error === 'undefined' ? 'undefined' : _typeof(error)) !== 'object' || !error.message || !error.stack) {
          error = new Error(error);
          error.stack = ''; // Remove stack for stack-less errors.
        }

        // $FlowFixMe: checking error code is OK if error comes from "fs".
        if (!['ENOENT', 'EACCES'].includes(error.code)) {
          throw error;
        }

        // If a file cannot be read we remove it from the file list and
        // ignore the failure silently.
        delete hasteMap.files[filePath];
      };

      // If we retain all files in the virtual HasteFS representation, we avoid
      // reading them if they aren't important (node_modules).
      if (this._options.retainAllFiles && this._isNodeModulesDir(filePath)) {
        if (computeSha1) {
          return this._getWorker(workerOptions).getSha1({
            computeDependencies: this._options.computeDependencies,
            computeSha1: computeSha1,
            filePath: filePath,
            hasteImplModulePath: this._options.hasteImplModulePath
          }).then(workerReply, workerError);
        }

        return null;
      }

      if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {
        var mockPath = (0, (_get_mock_name || _load_get_mock_name()).default)(filePath);
        if (mocks[mockPath]) {
          this._console.warn('jest-haste-map: duplicate manual mock found:\n' + ('  Module name: ' + mockPath + '\n') + ('  Duplicate Mock path: ' + filePath + '\nThis warning ') + 'is caused by two manual mock files with the same file name.\n' + 'Jest will use the mock file found in: \n' + (filePath + '\n') + ' Please delete one of the following two files: \n ' + (mocks[mockPath] + '\n' + filePath + '\n\n'));
        }
        mocks[mockPath] = filePath;
      }

      if (fileMetadata[(_constants || _load_constants()).default.VISITED]) {
        if (!fileMetadata[(_constants || _load_constants()).default.ID]) {
          return null;
        }

        if (moduleMetadata != null) {
          var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(filePath, this._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;

          var _module = moduleMetadata[platform];

          if (_module == null) {
            return null;
          }

          var modulesByPlatform = map[fileMetadata[(_constants || _load_constants()).default.ID]] || (map[fileMetadata[(_constants || _load_constants()).default.ID]] = {});
          modulesByPlatform[platform] = _module;

          return null;
        }
      }

      return this._getWorker(workerOptions).worker({
        computeDependencies: this._options.computeDependencies,
        computeSha1: computeSha1,
        filePath: filePath,
        hasteImplModulePath: this._options.hasteImplModulePath
      }).then(workerReply, workerError);
    }
  }, {
    key: '_buildHasteMap',
    value: function _buildHasteMap(data) {
      var _this5 = this;

      var deprecatedFiles = data.deprecatedFiles,
          hasteMap = data.hasteMap;

      var map = Object.create(null);
      var mocks = Object.create(null);
      var promises = [];

      for (var i = 0; i < deprecatedFiles.length; ++i) {
        var file = deprecatedFiles[i];
        this._recoverDuplicates(hasteMap, file.path, file.moduleName);
      }

      for (var filePath in hasteMap.files) {
        // SHA-1, if requested, should already be present thanks to the crawler.
        var promise = this._processFile(hasteMap, map, mocks, filePath);
        if (promise) {
          promises.push(promise);
        }
      }

      return Promise.all(promises).then(function () {
        _this5._cleanup();
        hasteMap.map = map;
        hasteMap.mocks = mocks;
        return hasteMap;
      }).catch(function (error) {
        _this5._cleanup();
        return Promise.reject(error);
      });
    }
  }, {
    key: '_cleanup',
    value: function _cleanup() {
      var worker = this._worker;

      // $FlowFixMe
      if (worker && typeof worker.end === 'function') {
        worker.end();
      }

      this._worker = null;
    }

    /**
     * 4. serialize the new `HasteMap` in a cache file.
     */

  }, {
    key: '_persist',
    value: function _persist(hasteMap) {
      (_jestSerializer || _load_jestSerializer()).default.writeFileSync(this._cachePath, hasteMap);
    }

    /**
     * Creates workers or parses files and extracts metadata in-process.
     */

  }, {
    key: '_getWorker',
    value: function _getWorker(options) {
      if (!this._worker) {
        if (options && options.forceInBand || this._options.maxWorkers <= 1) {
          this._worker = {
            getSha1: (_worker || _load_worker()).getSha1,
            worker: (_worker || _load_worker()).worker
          };
        } else {
          // $FlowFixMe: assignment of a worker with custom properties.
          this._worker = new (_jestWorker || _load_jestWorker()).default(require.resolve('./worker'), {
            exposedMethods: ['getSha1', 'worker'],
            maxRetries: 3,
            numWorkers: this._options.maxWorkers
          });
        }
      }

      return this._worker;
    }
  }, {
    key: '_crawl',
    value: function _crawl(hasteMap) {
      var _this6 = this;

      var options = this._options;
      var ignore = this._ignore.bind(this);
      var crawl = canUseWatchman && this._options.useWatchman ? (_watchman || _load_watchman()).default : (_node || _load_node()).default;

      var retry = function retry(error) {
        if (crawl === (_watchman || _load_watchman()).default) {
          _this6._console.warn('jest-haste-map: Watchman crawl failed. Retrying once with node ' + 'crawler.\n' + '  Usually this happens when watchman isn\'t running. Create an ' + 'empty `.watchmanconfig` file in your project\'s root folder or ' + 'initialize a git or hg repository in your project.\n' + '  ' + error);
          return (0, (_node || _load_node()).default)({
            computeSha1: options.computeSha1,
            data: hasteMap,
            extensions: options.extensions,
            forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
            ignore: ignore,
            roots: options.roots
          }).catch(function (e) {
            throw new Error('Crawler retry failed:\n' + ('  Original error: ' + error.message + '\n') + ('  Retry error: ' + e.message + '\n'));
          });
        }

        throw error;
      };

      try {
        return crawl({
          computeSha1: options.computeSha1,
          data: hasteMap,
          extensions: options.extensions,
          forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
          ignore: ignore,
          roots: options.roots
        }).catch(retry);
      } catch (error) {
        return retry(error);
      }
    }

    /**
     * Watch mode
     */

  }, {
    key: '_watch',
    value: function _watch(hasteMap, hasteFS, moduleMap) {
      var _this7 = this;

      if (!this._options.watch) {
        return Promise.resolve();
      }

      // In watch mode, we'll only warn about module collisions and we'll retain
      // all files, even changes to node_modules.
      this._options.throwOnModuleCollision = false;
      this._options.retainAllFiles = true;

      var Watcher = canUseWatchman && this._options.useWatchman ? (_watchman_watcher || _load_watchman_watcher()).default : (_os || _load_os()).default.platform() === 'darwin' ? (_sane || _load_sane()).default.FSEventsWatcher : (_sane || _load_sane()).default.NodeWatcher;
      var extensions = this._options.extensions;
      var ignorePattern = this._options.ignorePattern;
      var changeQueue = Promise.resolve();
      var eventsQueue = [];
      // We only need to copy the entire haste map once on every "frame".
      var mustCopy = true;

      var createWatcher = function createWatcher(root) {
        var watcher = new Watcher(root, {
          dot: false,
          glob: extensions.map(function (extension) {
            return '**/*.' + extension;
          }),
          ignored: ignorePattern
        });

        return new Promise(function (resolve, reject) {
          var rejectTimeout = setTimeout(function () {
            return reject(new Error('Failed to start watch mode.'));
          }, MAX_WAIT_TIME);

          watcher.once('ready', function () {
            clearTimeout(rejectTimeout);
            watcher.on('all', onChange);
            resolve(watcher);
          });
        });
      };

      var emitChange = function emitChange() {
        if (eventsQueue.length) {
          mustCopy = true;
          _this7.emit('change', {
            eventsQueue: eventsQueue,
            hasteFS: new (_haste_fs || _load_haste_fs()).default(hasteMap.files),
            moduleMap: new (_module_map || _load_module_map()).default({
              duplicates: hasteMap.duplicates,
              map: hasteMap.map,
              mocks: hasteMap.mocks
            })
          });
          eventsQueue = [];
        }
      };

      var onChange = function onChange(type, filePath, root, stat) {
        filePath = (_path || _load_path()).default.join(root, (0, (_normalize_path_sep || _load_normalize_path_sep()).default)(filePath));
        if (stat && stat.isDirectory() || _this7._ignore(filePath) || !extensions.some(function (extension) {
          return filePath.endsWith(extension);
        })) {
          return;
        }

        changeQueue = changeQueue.then(function () {
          // If we get duplicate events for the same file, ignore them.
          if (eventsQueue.find(function (event) {
            return event.type === type && event.filePath === filePath && (!event.stat && !stat || event.stat && stat && event.stat.mtime.getTime() === stat.mtime.getTime());
          })) {
            return null;
          }

          if (mustCopy) {
            mustCopy = false;
            hasteMap = {
              clocks: copy(hasteMap.clocks),
              duplicates: copy(hasteMap.duplicates),
              files: copy(hasteMap.files),
              map: copy(hasteMap.map),
              mocks: copy(hasteMap.mocks)
            };
          }

          var add = function add() {
            return eventsQueue.push({ filePath: filePath, stat: stat, type: type });
          };

          // Delete the file and all of its metadata.
          var moduleName = hasteMap.files[filePath] && hasteMap.files[filePath][(_constants || _load_constants()).default.ID];
          var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(filePath, _this7._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;

          delete hasteMap.files[filePath];
          var moduleMap = hasteMap.map[moduleName];
          if (moduleMap != null) {
            // We are forced to copy the object because jest-haste-map exposes
            // the map as an immutable entity.
            moduleMap = copy(moduleMap);
            delete moduleMap[platform];
            if (Object.keys(moduleMap).length === 0) {
              delete hasteMap.map[moduleName];
            } else {
              hasteMap.map[moduleName] = moduleMap;
            }
          }
          if (_this7._options.mocksPattern && _this7._options.mocksPattern.test(filePath)) {
            var mockName = (0, (_get_mock_name || _load_get_mock_name()).default)(filePath);
            delete hasteMap.mocks[mockName];
          }

          _this7._recoverDuplicates(hasteMap, filePath, moduleName);

          // If the file was added or changed,
          // parse it and update the haste map.
          if (type === 'add' || type === 'change') {
            (0, (_invariant || _load_invariant()).default)(stat, 'since the file exists or changed, it should have stats');
            var fileMetadata = ['', stat.mtime.getTime(), 0, [], null];
            hasteMap.files[filePath] = fileMetadata;
            var promise = _this7._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, { forceInBand: true });
            // Cleanup
            _this7._cleanup();
            if (promise) {
              return promise.then(add);
            } else {
              // If a file in node_modules has changed,
              // emit an event regardless.
              add();
            }
          } else {
            add();
          }
          return null;
        }).catch(function (error) {
          _this7._console.error('jest-haste-map: watch error:\n  ' + error.stack + '\n');
        });
      };

      this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);
      return Promise.all(this._options.roots.map(createWatcher)).then(function (watchers) {
        _this7._watchers = watchers;
      });
    }

    /**
     * This function should be called when the file under `filePath` is removed
     * or changed. When that happens, we want to figure out if that file was
     * part of a group of files that had the same ID. If it was, we want to
     * remove it from the group. Furthermore, if there is only one file
     * remaining in the group, then we want to restore that single file as the
     * correct resolution for its ID, and cleanup the duplicates index.
     */

  }, {
    key: '_recoverDuplicates',
    value: function _recoverDuplicates(hasteMap, filePath, moduleName) {
      var dupsByPlatform = hasteMap.duplicates[moduleName];
      if (dupsByPlatform == null) {
        return;
      }
      var platform = (0, (_get_platform_extension || _load_get_platform_extension()).default)(filePath, this._options.platforms) || (_constants || _load_constants()).default.GENERIC_PLATFORM;
      var dups = dupsByPlatform[platform];
      if (dups == null) {
        return;
      }
      dupsByPlatform = hasteMap.duplicates[moduleName] = copy(dupsByPlatform);
      dups = dupsByPlatform[platform] = copy(dups);
      var dedupType = dups[filePath];
      delete dups[filePath];
      var filePaths = Object.keys(dups);
      if (filePaths.length > 1) {
        return;
      }
      var dedupMap = hasteMap.map[moduleName];
      if (dedupMap == null) {
        dedupMap = hasteMap.map[moduleName] = Object.create(null);
      }
      dedupMap[platform] = [filePaths[0], dedupType];
      delete dupsByPlatform[platform];
      if (Object.keys(dupsByPlatform).length === 0) {
        delete hasteMap.duplicates[moduleName];
      }
    }
  }, {
    key: 'end',
    value: function end() {
      var _this8 = this;

      clearInterval(this._changeInterval);
      if (!this._watchers.length) {
        return Promise.resolve();
      }

      return Promise.all(this._watchers.map(function (watcher) {
        return new Promise(function (resolve) {
          return watcher.close(resolve);
        });
      })).then(function () {
        _this8._watchers = [];
      });
    }

    /**
     * Helpers
     */

  }, {
    key: '_ignore',
    value: function _ignore(filePath) {
      var ignorePattern = this._options.ignorePattern;
      var ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern(filePath);

      return ignoreMatched || !this._options.retainAllFiles && this._isNodeModulesDir(filePath);
    }
  }, {
    key: '_isNodeModulesDir',
    value: function _isNodeModulesDir(filePath) {
      if (!filePath.includes(NODE_MODULES)) {
        return false;
      }

      if (this._whitelist) {
        var whitelist = this._whitelist;
        var match = whitelist.exec(filePath);
        var matchEndIndex = whitelist.lastIndex;
        whitelist.lastIndex = 0;

        if (!match) {
          return true;
        }

        var filePathInPackage = filePath.substr(matchEndIndex);
        return filePathInPackage.startsWith(NODE_MODULES);
      }

      return true;
    }
  }, {
    key: '_createEmptyMap',
    value: function _createEmptyMap() {
      // $FlowFixMe
      return {
        clocks: Object.create(null),
        duplicates: Object.create(null),
        files: Object.create(null),
        map: Object.create(null),
        mocks: Object.create(null)
      };
    }
  }], [{
    key: 'getCacheFilePath',
    value: function getCacheFilePath(tmpdir, name) {
      for (var _len = arguments.length, extra = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        extra[_key - 2] = arguments[_key];
      }

      var hash = (_crypto || _load_crypto()).default.createHash('md5').update(name + extra.join(''));
      return (_path || _load_path()).default.join(tmpdir, name.replace(/\W/g, '-') + '-' + hash.digest('hex'));
    }
  }]);

  return HasteMap;
}((_events || _load_events()).default);

var copy = function copy(object) {
  return Object.assign(Object.create(null), object);
};

HasteMap.H = (_constants || _load_constants()).default;
HasteMap.ModuleMap = (_module_map || _load_module_map()).default;

module.exports = HasteMap;