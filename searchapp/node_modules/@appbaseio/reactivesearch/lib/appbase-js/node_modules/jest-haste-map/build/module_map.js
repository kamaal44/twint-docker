'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _constants;

function _load_constants() {
  return _constants = _interopRequireDefault(require('./constants'));
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var EMPTY_MAP = {};
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var ModuleMap = function () {
  function ModuleMap(raw) {
    _classCallCheck(this, ModuleMap);

    this._raw = raw;
  }

  _createClass(ModuleMap, [{
    key: 'getModule',
    value: function getModule(name, platform, supportsNativePlatform, type) {
      if (!type) {
        type = (_constants || _load_constants()).default.MODULE;
      }
      var module = this._getModuleMetadata(name, platform, !!supportsNativePlatform);
      if (module && module[(_constants || _load_constants()).default.TYPE] === type) {
        return module[(_constants || _load_constants()).default.PATH];
      }
      return null;
    }
  }, {
    key: 'getPackage',
    value: function getPackage(name, platform, supportsNativePlatform) {
      return this.getModule(name, platform, null, (_constants || _load_constants()).default.PACKAGE);
    }
  }, {
    key: 'getMockModule',
    value: function getMockModule(name) {
      return this._raw.mocks[name] || this._raw.mocks[name + '/index'];
    }
  }, {
    key: 'getRawModuleMap',
    value: function getRawModuleMap() {
      return {
        duplicates: this._raw.duplicates,
        map: this._raw.map,
        mocks: this._raw.mocks
      };
    }

    /**
     * When looking up a module's data, we walk through each eligible platform for
     * the query. For each platform, we want to check if there are known
     * duplicates for that name+platform pair. The duplication logic normally
     * removes elements from the `map` object, but we want to check upfront to be
     * extra sure. If metadata exists both in the `duplicates` object and the
     * `map`, this would be a bug.
     */

  }, {
    key: '_getModuleMetadata',
    value: function _getModuleMetadata(name, platform, supportsNativePlatform) {
      var map = this._raw.map[name] || EMPTY_MAP;
      var dupMap = this._raw.duplicates[name] || EMPTY_MAP;
      if (platform != null) {
        this._assertNoDuplicates(name, platform, supportsNativePlatform, dupMap[platform]);
        if (map[platform] != null) {
          return map[platform];
        }
      }
      if (supportsNativePlatform) {
        this._assertNoDuplicates(name, (_constants || _load_constants()).default.NATIVE_PLATFORM, supportsNativePlatform, dupMap[(_constants || _load_constants()).default.NATIVE_PLATFORM]);
        if (map[(_constants || _load_constants()).default.NATIVE_PLATFORM]) {
          return map[(_constants || _load_constants()).default.NATIVE_PLATFORM];
        }
      }
      this._assertNoDuplicates(name, (_constants || _load_constants()).default.GENERIC_PLATFORM, supportsNativePlatform, dupMap[(_constants || _load_constants()).default.GENERIC_PLATFORM]);
      if (map[(_constants || _load_constants()).default.GENERIC_PLATFORM]) {
        return map[(_constants || _load_constants()).default.GENERIC_PLATFORM];
      }
      return null;
    }
  }, {
    key: '_assertNoDuplicates',
    value: function _assertNoDuplicates(name, platform, supportsNativePlatform, set) {
      if (set == null) {
        return;
      }
      throw new DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, set);
    }
  }]);

  return ModuleMap;
}();

exports.default = ModuleMap;

var DuplicateHasteCandidatesError = function (_Error) {
  _inherits(DuplicateHasteCandidatesError, _Error);

  function DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, duplicatesSet) {
    _classCallCheck(this, DuplicateHasteCandidatesError);

    var platformMessage = getPlatformMessage(platform);

    var _this = _possibleConstructorReturn(this, (DuplicateHasteCandidatesError.__proto__ || Object.getPrototypeOf(DuplicateHasteCandidatesError)).call(this, 'The name `' + name + '` was looked up in the Haste module map. It ' + 'cannot be resolved, because there exists several different ' + 'files, or packages, that provide a module for ' + ('that particular name and platform. ' + platformMessage + ' You must ') + 'delete or blacklist files until there remains only one of these:\n\n' + Object.keys(duplicatesSet).sort().map(function (dupFilePath) {
      var typeMessage = getTypeMessage(duplicatesSet[dupFilePath]);
      return '  * `' + dupFilePath + '` (' + typeMessage + ')\n';
    }).join('')));

    _this.hasteName = name;
    _this.platform = platform;
    _this.supportsNativePlatform = supportsNativePlatform;
    _this.duplicatesSet = duplicatesSet;
    return _this;
  }

  return DuplicateHasteCandidatesError;
}(Error);

function getPlatformMessage(platform) {
  if (platform === (_constants || _load_constants()).default.GENERIC_PLATFORM) {
    return 'The platform is generic (no extension).';
  }
  return 'The platform extension is `' + platform + '`.';
}

function getTypeMessage(type) {
  switch (type) {
    case (_constants || _load_constants()).default.MODULE:
      return 'module';
    case (_constants || _load_constants()).default.PACKAGE:
      return 'package';
  }
  return 'unknown';
}

ModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;