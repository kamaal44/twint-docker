/**
 * Copyright (c) 2018-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.deserialize = deserialize;
exports.serialize = serialize;
exports.readFileSync = readFileSync;
exports.writeFileSync = writeFileSync;

var _fs;

function _load_fs() {
  return _fs = _interopRequireDefault(require('fs'));
}

var _v;

function _load_v() {
  return _v = _interopRequireDefault(require('v8'));
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// JSON and V8 serializers are both stable when it comes to compatibility. The
// current JSON specification is well defined in RFC 8259, and V8 ensures that
// the versions are compatible by encoding the serialization version in the own
// generated buffer.

var JS_TYPE = '__$t__';
var JS_VALUE = '__$v__';
var JS_VF = '__$f__';

function replacer(key, value) {
  var _ref5, _ref6, _ref7, _ref8, _ref9;

  // NaN cannot be in a switch statement, because NaN !== NaN.
  if (Number.isNaN(value)) {
    return _defineProperty({}, JS_TYPE, 'n');
  }

  switch (value) {
    case undefined:
      return _defineProperty({}, JS_TYPE, 'u');

    case +Infinity:
      return _defineProperty({}, JS_TYPE, '+');

    case -Infinity:
      return _defineProperty({}, JS_TYPE, '-');
  }

  switch (value && value.constructor) {
    case Date:
      return _ref5 = {}, _defineProperty(_ref5, JS_TYPE, 'd'), _defineProperty(_ref5, JS_VALUE, value.getTime()), _ref5;

    case RegExp:
      return _ref6 = {}, _defineProperty(_ref6, JS_TYPE, 'r'), _defineProperty(_ref6, JS_VALUE, value.source), _defineProperty(_ref6, JS_VF, value.flags), _ref6;

    case Set:
      return _ref7 = {}, _defineProperty(_ref7, JS_TYPE, 's'), _defineProperty(_ref7, JS_VALUE, Array.from(value)), _ref7;

    case Map:
      return _ref8 = {}, _defineProperty(_ref8, JS_TYPE, 'm'), _defineProperty(_ref8, JS_VALUE, Array.from(value)), _ref8;

    case Buffer:
      return _ref9 = {}, _defineProperty(_ref9, JS_TYPE, 'b'), _defineProperty(_ref9, JS_VALUE, value.toString('latin1')), _ref9;
  }

  return value;
}

function reviver(key, value) {
  if (!value || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' && !value.hasOwnProperty(JS_TYPE)) {
    return value;
  }

  switch (value[JS_TYPE]) {
    case 'u':
      return undefined;

    case 'n':
      return NaN;

    case '+':
      return +Infinity;

    case '-':
      return -Infinity;

    case 'd':
      return new Date(value[JS_VALUE]);

    case 'r':
      return new RegExp(value[JS_VALUE], value[JS_VF]);

    case 's':
      return new Set(value[JS_VALUE]);

    case 'm':
      return new Map(value[JS_VALUE]);

    case 'b':
      return Buffer.from(value[JS_VALUE], 'latin1');
  }

  return value;
}

function jsonStringify(content) {
  // Not pretty, but the ES JSON spec says that "toJSON" will be called before
  // getting into your replacer, so we have to remove them beforehand. See
  // https://www.ecma-international.org/ecma-262/#sec-serializejsonproperty
  // section 2.b for more information.

  var dateToJSON = Date.prototype.toJSON;
  var bufferToJSON = Buffer.prototype.toJSON;

  /* eslint-disable no-extend-native */

  try {
    // $FlowFixMe: intentional removal of "toJSON" property.
    Date.prototype.toJSON = undefined;
    // $FlowFixMe: intentional removal of "toJSON" property.
    Buffer.prototype.toJSON = undefined;

    return JSON.stringify(content, replacer);
  } finally {
    // $FlowFixMe: intentional assignment of "toJSON" property.
    Date.prototype.toJSON = dateToJSON;
    // $FlowFixMe: intentional assignment of "toJSON" property.
    Buffer.prototype.toJSON = bufferToJSON;
  }

  /* eslint-enable no-extend-native */
}

function jsonParse(content) {
  return JSON.parse(content, reviver);
}

// In memory functions.

function deserialize(buffer) {
  // $FlowFixMe - Node 8+ only
  return (_v || _load_v()).default.deserialize ? (_v || _load_v()).default.deserialize(buffer) : jsonParse(buffer.toString('utf8'));
}

function serialize(content) {
  // $FlowFixMe - Node 8+ only
  return (_v || _load_v()).default.serialize ? (_v || _load_v()).default.serialize(content) : Buffer.from(jsonStringify(content));
}

// Synchronous filesystem functions.

function readFileSync(filePath) {
  // $FlowFixMe - Node 8+ only
  return (_v || _load_v()).default.deserialize ? (_v || _load_v()).default.deserialize((_fs || _load_fs()).default.readFileSync(filePath)) : jsonParse((_fs || _load_fs()).default.readFileSync(filePath, 'utf8'));
}

function writeFileSync(filePath, content) {
  // $FlowFixMe - Node 8+ only
  return (_v || _load_v()).default.serialize ? (_fs || _load_fs()).default.writeFileSync(filePath, (_v || _load_v()).default.serialize(content)) : (_fs || _load_fs()).default.writeFileSync(filePath, jsonStringify(content), 'utf8');
}

exports.default = {
  deserialize: deserialize,
  readFileSync: readFileSync,
  serialize: serialize,
  writeFileSync: writeFileSync
};