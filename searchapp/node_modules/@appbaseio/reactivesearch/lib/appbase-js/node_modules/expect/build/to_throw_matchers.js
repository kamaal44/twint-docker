'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createMatcher = undefined;

var _jestGetType = require('jest-get-type');

var _jestGetType2 = _interopRequireDefault(_jestGetType);

var _jestRegexUtil = require('jest-regex-util');

var _jestMessageUtil = require('jest-message-util');

var _jestMatcherUtils = require('jest-matcher-utils');

var _jasmine_utils = require('./jasmine_utils');

var _utils = require('./utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createMatcher = exports.createMatcher = function (matcherName, fromPromise) {
  return function (actual, expected) {
    var value = expected;
    var error = void 0;

    if (fromPromise && (0, _utils.isError)(actual)) {
      error = actual;
    } else {
      if (typeof actual !== 'function') {
        if (!fromPromise) {
          throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, 'function', (0, _jestGetType2.default)(value)) + '\n\n' + 'Received value must be a function, but instead ' + ('"' + (0, _jestGetType2.default)(actual) + '" was found'));
        }
      } else {
        try {
          actual();
        } catch (e) {
          error = e;
        }
      }
    }

    if (typeof expected === 'string') {
      expected = new RegExp((0, _jestRegexUtil.escapeStrForRegex)(expected));
    }

    if (typeof expected === 'function') {
      return toThrowMatchingError(matcherName, error, expected);
    } else if (expected && typeof expected.test === 'function') {
      return toThrowMatchingStringOrRegexp(matcherName, error, expected, value);
    } else if (expected && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) === 'object') {
      return toThrowMatchingErrorInstance(matcherName, error, expected);
    } else if (expected === undefined) {
      var pass = error !== undefined;
      return {
        message: pass ? function () {
          return (0, _jestMatcherUtils.matcherHint)('.not' + matcherName, 'function', '') + '\n\n' + 'Expected the function not to throw an error.\n' + printActualErrorMessage(error);
        } : function () {
          return (0, _jestMatcherUtils.matcherHint)(matcherName, 'function', (0, _jestGetType2.default)(value)) + '\n\n' + 'Expected the function to throw an error.\n' + printActualErrorMessage(error);
        },
        pass: pass
      };
    } else {
      throw new Error((0, _jestMatcherUtils.matcherHint)('.not' + matcherName, 'function', (0, _jestGetType2.default)(value)) + '\n\n' + 'Unexpected argument passed.\nExpected: ' + ((0, _jestMatcherUtils.printExpected)('string') + ', ' + (0, _jestMatcherUtils.printExpected)('Error (type)') + ' or ' + (0, _jestMatcherUtils.printExpected)('regexp') + '.\n') + (0, _jestMatcherUtils.printWithType)('Got', String(expected), _jestMatcherUtils.printExpected));
    }
  };
};
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var matchers = {
  toThrow: createMatcher('.toThrow'),
  toThrowError: createMatcher('.toThrowError')
};

var toThrowMatchingStringOrRegexp = function toThrowMatchingStringOrRegexp(name, error, pattern, value) {
  if (error && !error.message && !error.name) {
    error = new Error(error);
  }

  var pass = !!(error && error.message.match(pattern));
  var message = pass ? function () {
    return (0, _jestMatcherUtils.matcherHint)('.not' + name, 'function', (0, _jestGetType2.default)(value)) + '\n\n' + 'Expected the function not to throw an error matching:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(value) + '\n') + printActualErrorMessage(error);
  } : function () {
    return (0, _jestMatcherUtils.matcherHint)(name, 'function', (0, _jestGetType2.default)(value)) + '\n\n' + 'Expected the function to throw an error matching:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(value) + '\n') + printActualErrorMessage(error);
  };

  return { message: message, pass: pass };
};

var toThrowMatchingErrorInstance = function toThrowMatchingErrorInstance(name, error, expectedError) {
  if (error && !error.message && !error.name) {
    error = new Error(error);
  }

  var pass = (0, _jasmine_utils.equals)(error, expectedError);
  var message = pass ? function () {
    return (0, _jestMatcherUtils.matcherHint)('.not' + name, 'function', 'error') + '\n\n' + 'Expected the function not to throw an error matching:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expectedError) + '\n') + printActualErrorMessage(error);
  } : function () {
    return (0, _jestMatcherUtils.matcherHint)(name, 'function', 'error') + '\n\n' + 'Expected the function to throw an error matching:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(expectedError) + '\n') + printActualErrorMessage(error);
  };

  return { message: message, pass: pass };
};

var toThrowMatchingError = function toThrowMatchingError(name, error, ErrorClass) {
  var pass = !!(error && error instanceof ErrorClass);
  var message = pass ? function () {
    return (0, _jestMatcherUtils.matcherHint)('.not' + name, 'function', 'type') + '\n\n' + 'Expected the function not to throw an error of type:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(ErrorClass.name) + '\n') + printActualErrorMessage(error);
  } : function () {
    return (0, _jestMatcherUtils.matcherHint)(name, 'function', 'type') + '\n\n' + 'Expected the function to throw an error of type:\n' + ('  ' + (0, _jestMatcherUtils.printExpected)(ErrorClass.name) + '\n') + printActualErrorMessage(error);
  };

  return { message: message, pass: pass };
};

var printActualErrorMessage = function printActualErrorMessage(error) {
  if (error) {
    var _separateMessageFromS = (0, _jestMessageUtil.separateMessageFromStack)(error.stack);

    var message = _separateMessageFromS.message,
        stack = _separateMessageFromS.stack;

    return 'Instead, it threw:\n' + (0, _jestMatcherUtils.RECEIVED_COLOR)('  ' + (0, _jestMatcherUtils.highlightTrailingWhitespace)(message) + (0, _jestMessageUtil.formatStackTrace)(stack, {
      rootDir: process.cwd(),
      testMatch: []
    }, {
      noStackTrace: false
    }));
  }

  return 'But it didn\'t throw anything.';
};

exports.default = matchers;