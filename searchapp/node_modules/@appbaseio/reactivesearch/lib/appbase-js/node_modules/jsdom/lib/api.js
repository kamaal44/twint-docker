"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var path = require("path");
var fs = require("pn/fs");
var vm = require("vm");
var toughCookie = require("tough-cookie");
var request = require("request-promise-native");
var sniffHTMLEncoding = require("html-encoding-sniffer");
var whatwgURL = require("whatwg-url");
var whatwgEncoding = require("whatwg-encoding");

var _require = require("whatwg-url"),
    URL = _require.URL;

var MIMEType = require("whatwg-mimetype");
var idlUtils = require("./jsdom/living/generated/utils.js");
var VirtualConsole = require("./jsdom/virtual-console.js");
var Window = require("./jsdom/browser/Window.js");

var _require2 = require("./jsdom/browser/domtohtml.js"),
    domToHtml = _require2.domToHtml;

var _require3 = require("./jsdom/browser/documentfeatures.js"),
    applyDocumentFeatures = _require3.applyDocumentFeatures;

var _require4 = require("./jsdom/browser/resource-loader.js"),
    wrapCookieJarForRequest = _require4.wrapCookieJarForRequest;

var _require5 = require("../package.json"),
    packageVersion = _require5.version;

var DEFAULT_USER_AGENT = "Mozilla/5.0 (" + process.platform + ") AppleWebKit/537.36 (KHTML, like Gecko) " + ("jsdom/" + packageVersion);

// This symbol allows us to smuggle a non-public option through to the JSDOM constructor, for use by JSDOM.fromURL.
var transportLayerEncodingLabelHiddenOption = Symbol("transportLayerEncodingLabel");

var CookieJar = function (_toughCookie$CookieJa) {
  _inherits(CookieJar, _toughCookie$CookieJa);

  function CookieJar(store, options) {
    _classCallCheck(this, CookieJar);

    // jsdom cookie jars must be loose by default
    return _possibleConstructorReturn(this, (CookieJar.__proto__ || Object.getPrototypeOf(CookieJar)).call(this, store, Object.assign({ looseMode: true }, options)));
  }

  return CookieJar;
}(toughCookie.CookieJar);

var window = Symbol("window");
var sharedFragmentDocument = null;

var JSDOM = function () {
  function JSDOM(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, JSDOM);

    var _normalizeHTML = normalizeHTML(input, options[transportLayerEncodingLabelHiddenOption]),
        html = _normalizeHTML.html,
        encoding = _normalizeHTML.encoding;

    options = transformOptions(options, encoding);

    this[window] = new Window(options.windowOptions);

    // TODO NEWAPI: the whole "features" infrastructure is horrible and should be re-built. When we switch to newapi
    // wholesale, or perhaps before, we should re-do it. For now, just adapt the new, nice, public API into the old,
    // ugly, internal API.
    var features = {
      FetchExternalResources: [],
      SkipExternalResources: false
    };

    if (options.resources === "usable") {
      features.FetchExternalResources = ["link", "img", "frame", "iframe"];
      if (options.windowOptions.runScripts === "dangerously") {
        features.FetchExternalResources.push("script");
      }

      // Note that "img" will be ignored by the code in HTMLImageElement-impl.js if canvas is not installed.
      // TODO NEWAPI: clean that up and centralize the logic here.
    }

    var documentImpl = idlUtils.implForWrapper(this[window]._document);
    applyDocumentFeatures(documentImpl, features);

    options.beforeParse(this[window]._globalProxy);

    // TODO NEWAPI: this is still pretty hacky. It's also different than jsdom.jsdom. Does it work? Can it be better?
    documentImpl._htmlToDom.appendToDocument(html, documentImpl);
    documentImpl.close();
  }

  _createClass(JSDOM, [{
    key: "serialize",
    value: function serialize() {
      return domToHtml([idlUtils.implForWrapper(this[window]._document)]);
    }
  }, {
    key: "nodeLocation",
    value: function nodeLocation(node) {
      if (!idlUtils.implForWrapper(this[window]._document)._parseOptions.locationInfo) {
        throw new Error("Location information was not saved for this jsdom. Use includeNodeLocations during creation.");
      }

      return idlUtils.implForWrapper(node).__location;
    }
  }, {
    key: "runVMScript",
    value: function runVMScript(script) {
      if (!vm.isContext(this[window])) {
        throw new TypeError("This jsdom was not configured to allow script running. " + "Use the runScripts option during creation.");
      }

      return script.runInContext(this[window]);
    }
  }, {
    key: "reconfigure",
    value: function reconfigure(settings) {
      if ("windowTop" in settings) {
        this[window]._top = settings.windowTop;
      }

      if ("url" in settings) {
        var document = idlUtils.implForWrapper(this[window]._document);

        var url = whatwgURL.parseURL(settings.url);
        if (url === null) {
          throw new TypeError("Could not parse \"" + settings.url + "\" as a URL");
        }

        document._URL = url;
        document.origin = whatwgURL.serializeURLOrigin(document._URL);
      }
    }
  }, {
    key: "window",
    get: function get() {
      // It's important to grab the global proxy, instead of just the result of `new Window(...)`, since otherwise things
      // like `window.eval` don't exist.
      return this[window]._globalProxy;
    }
  }, {
    key: "virtualConsole",
    get: function get() {
      return this[window]._virtualConsole;
    }
  }, {
    key: "cookieJar",
    get: function get() {
      // TODO NEWAPI move _cookieJar to window probably
      return idlUtils.implForWrapper(this[window]._document)._cookieJar;
    }
  }], [{
    key: "fragment",
    value: function fragment(string) {
      if (!sharedFragmentDocument) {
        sharedFragmentDocument = new JSDOM().window.document;
      }

      var template = sharedFragmentDocument.createElement("template");
      template.innerHTML = string;
      return template.content;
    }
  }, {
    key: "fromURL",
    value: function fromURL(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return Promise.resolve().then(function () {
        var parsedURL = new URL(url);
        url = parsedURL.href;
        options = normalizeFromURLOptions(options);

        var requestOptions = {
          resolveWithFullResponse: true,
          encoding: null, // i.e., give me the raw Buffer
          gzip: true,
          headers: {
            "User-Agent": options.userAgent,
            Referer: options.referrer,
            Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en"
          },
          jar: wrapCookieJarForRequest(options.cookieJar)
        };

        return request(url, requestOptions).then(function (res) {
          var transportLayerEncodingLabel = void 0;
          if ("content-type" in res.headers) {
            var mimeType = new MIMEType(res.headers["content-type"]);
            transportLayerEncodingLabel = mimeType.parameters.get("charset");
          }

          options = Object.assign(options, _defineProperty({
            url: res.request.href + parsedURL.hash,
            contentType: res.headers["content-type"],
            referrer: res.request.getHeader("referer")
          }, transportLayerEncodingLabelHiddenOption, transportLayerEncodingLabel));

          return new JSDOM(res.body, options);
        });
      });
    }
  }, {
    key: "fromFile",
    value: function fromFile(filename) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return Promise.resolve().then(function () {
        options = normalizeFromFileOptions(filename, options);

        return fs.readFile(filename).then(function (buffer) {
          return new JSDOM(buffer, options);
        });
      });
    }
  }]);

  return JSDOM;
}();

function normalizeFromURLOptions(options) {
  // Checks on options that are invalid for `fromURL`
  if (options.url !== undefined) {
    throw new TypeError("Cannot supply a url option when using fromURL");
  }
  if (options.contentType !== undefined) {
    throw new TypeError("Cannot supply a contentType option when using fromURL");
  }

  // Normalization of options which must be done before the rest of the fromURL code can use them, because they are
  // given to request()
  var normalized = Object.assign({}, options);
  if (options.userAgent === undefined) {
    normalized.userAgent = DEFAULT_USER_AGENT;
  }

  if (options.referrer !== undefined) {
    normalized.referrer = new URL(options.referrer).href;
  }

  if (options.cookieJar === undefined) {
    normalized.cookieJar = new CookieJar();
  }

  return normalized;

  // All other options don't need to be processed yet, and can be taken care of in the normal course of things when
  // `fromURL` calls `new JSDOM(html, options)`.
}

function normalizeFromFileOptions(filename, options) {
  var normalized = Object.assign({}, options);

  if (normalized.contentType === undefined) {
    var extname = path.extname(filename);
    if (extname === ".xhtml" || extname === ".xml") {
      normalized.contentType = "application/xhtml+xml";
    }
  }

  if (normalized.url === undefined) {
    normalized.url = new URL("file:" + path.resolve(filename));
  }

  return normalized;
}

function transformOptions(options, encoding) {
  var transformed = {
    windowOptions: {
      // Defaults
      url: "about:blank",
      referrer: "",
      contentType: "text/html",
      parsingMode: "html",
      userAgent: DEFAULT_USER_AGENT,
      parseOptions: { locationInfo: false },
      runScripts: undefined,
      encoding: encoding,
      pretendToBeVisual: false,
      storageQuota: 5000000,

      // Defaults filled in later
      virtualConsole: undefined,
      cookieJar: undefined
    },

    // Defaults
    resources: undefined,
    beforeParse: function beforeParse() {}
  };

  if (options.contentType !== undefined) {
    var mimeType = new MIMEType(options.contentType);

    if (!mimeType.isHTML() && !mimeType.isXML()) {
      throw new RangeError("The given content type of \"" + options.contentType + "\" was not a HTML or XML content type");
    }

    transformed.windowOptions.contentType = mimeType.essence;
    transformed.windowOptions.parsingMode = mimeType.isHTML() ? "html" : "xml";
  }

  if (options.url !== undefined) {
    transformed.windowOptions.url = new URL(options.url).href;
  }

  if (options.referrer !== undefined) {
    transformed.windowOptions.referrer = new URL(options.referrer).href;
  }

  if (options.userAgent !== undefined) {
    transformed.windowOptions.userAgent = String(options.userAgent);
  }

  if (options.includeNodeLocations) {
    if (transformed.windowOptions.parsingMode === "xml") {
      throw new TypeError("Cannot set includeNodeLocations to true with an XML content type");
    }

    transformed.windowOptions.parseOptions = { locationInfo: true };
  }

  transformed.windowOptions.cookieJar = options.cookieJar === undefined ? new CookieJar() : options.cookieJar;

  transformed.windowOptions.virtualConsole = options.virtualConsole === undefined ? new VirtualConsole().sendTo(console) : options.virtualConsole;

  if (options.resources !== undefined) {
    transformed.resources = String(options.resources);
    if (transformed.resources !== "usable") {
      throw new RangeError("resources must be undefined or \"usable\"");
    }
  }

  if (options.runScripts !== undefined) {
    transformed.windowOptions.runScripts = String(options.runScripts);
    if (transformed.windowOptions.runScripts !== "dangerously" && transformed.windowOptions.runScripts !== "outside-only") {
      throw new RangeError("runScripts must be undefined, \"dangerously\", or \"outside-only\"");
    }
  }

  if (options.beforeParse !== undefined) {
    transformed.beforeParse = options.beforeParse;
  }

  if (options.pretendToBeVisual !== undefined) {
    transformed.windowOptions.pretendToBeVisual = Boolean(options.pretendToBeVisual);
  }

  if (options.storageQuota !== undefined) {
    transformed.windowOptions.storageQuota = Number(options.storageQuota);
  }

  // concurrentNodeIterators??

  return transformed;
}

function normalizeHTML() {
  var html = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  var transportLayerEncodingLabel = arguments[1];

  var encoding = "UTF-8";

  if (ArrayBuffer.isView(html)) {
    html = Buffer.from(html.buffer, html.byteOffset, html.byteLength);
  } else if (html instanceof ArrayBuffer) {
    html = Buffer.from(html);
  }

  if (Buffer.isBuffer(html)) {
    encoding = sniffHTMLEncoding(html, { defaultEncoding: "windows-1252", transportLayerEncodingLabel: transportLayerEncodingLabel });
    html = whatwgEncoding.decode(html, encoding);
  } else {
    html = String(html);
  }

  return { html: html, encoding: encoding };
}

exports.JSDOM = JSDOM;

exports.VirtualConsole = VirtualConsole;
exports.CookieJar = CookieJar;

exports.toughCookie = toughCookie;