'use strict';

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MOCK_CONSTRUCTOR_NAME = 'mockConstructor';

/**
 * Represents the result of a single call to a mock function.
 */

var FUNCTION_NAME_RESERVED_PATTERN = /[\s!-\/:-@\[-`{-~]/;
var FUNCTION_NAME_RESERVED_REPLACE = new RegExp(FUNCTION_NAME_RESERVED_PATTERN.source, 'g');

var RESERVED_KEYWORDS = Object.assign(Object.create(null), {
  arguments: true,
  await: true,
  break: true,
  case: true,
  catch: true,
  class: true,
  const: true,
  continue: true,
  debugger: true,
  default: true,
  delete: true,
  do: true,
  else: true,
  enum: true,
  eval: true,
  export: true,
  extends: true,
  false: true,
  finally: true,
  for: true,
  function: true,
  if: true,
  implements: true,
  import: true,
  in: true,
  instanceof: true,
  interface: true,
  let: true,
  new: true,
  null: true,
  package: true,
  private: true,
  protected: true,
  public: true,
  return: true,
  static: true,
  super: true,
  switch: true,
  this: true,
  throw: true,
  true: true,
  try: true,
  typeof: true,
  var: true,
  void: true,
  while: true,
  with: true,
  yield: true
});

function matchArity(fn, length) {
  var mockConstructor = void 0;

  switch (length) {
    case 1:
      mockConstructor = function mockConstructor(a) {
        return fn.apply(this, arguments);
      };
      break;
    case 2:
      mockConstructor = function mockConstructor(a, b) {
        return fn.apply(this, arguments);
      };
      break;
    case 3:
      mockConstructor = function mockConstructor(a, b, c) {
        return fn.apply(this, arguments);
      };
      break;
    case 4:
      mockConstructor = function mockConstructor(a, b, c, d) {
        return fn.apply(this, arguments);
      };
      break;
    case 5:
      mockConstructor = function mockConstructor(a, b, c, d, e) {
        return fn.apply(this, arguments);
      };
      break;
    case 6:
      mockConstructor = function mockConstructor(a, b, c, d, e, f) {
        return fn.apply(this, arguments);
      };
      break;
    case 7:
      mockConstructor = function mockConstructor(a, b, c, d, e, f, g) {
        return fn.apply(this, arguments);
      };
      break;
    case 8:
      mockConstructor = function mockConstructor(a, b, c, d, e, f, g, h) {
        return fn.apply(this, arguments);
      };
      break;
    case 9:
      mockConstructor = function mockConstructor(a, b, c, d, e, f, g, h, i) {
        return fn.apply(this, arguments);
      };
      break;
    default:
      mockConstructor = function mockConstructor() {
        return fn.apply(this, arguments);
      };
      break;
  }

  return mockConstructor;
}

function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function getType(ref) {
  if (isA('Function', ref) || isA('AsyncFunction', ref) || isA('GeneratorFunction', ref)) {
    return 'function';
  } else if (Array.isArray(ref)) {
    return 'array';
  } else if (isA('Object', ref)) {
    return 'object';
  } else if (isA('Number', ref) || isA('String', ref) || isA('Boolean', ref) || isA('Symbol', ref)) {
    return 'constant';
  } else if (isA('Map', ref) || isA('WeakMap', ref) || isA('Set', ref)) {
    return 'collection';
  } else if (isA('RegExp', ref)) {
    return 'regexp';
  } else if (ref === undefined) {
    return 'undefined';
  } else if (ref === null) {
    return 'null';
  } else {
    return null;
  }
}

function isReadonlyProp(object, prop) {
  return (prop === 'arguments' || prop === 'caller' || prop === 'callee' || prop === 'name' || prop === 'length') && (isA('Function', object) || isA('AsyncFunction', object) || isA('GeneratorFunction', object)) || (prop === 'source' || prop === 'global' || prop === 'ignoreCase' || prop === 'multiline') && isA('RegExp', object);
}

function getSlots(object) {
  var slots = {};
  if (!object) {
    return [];
  }

  var parent = Object.getPrototypeOf(object);
  do {
    if (object === Object.getPrototypeOf(Function)) {
      break;
    }
    var ownNames = Object.getOwnPropertyNames(object);
    for (var i = 0; i < ownNames.length; i++) {
      var prop = ownNames[i];
      if (!isReadonlyProp(object, prop)) {
        var propDesc = Object.getOwnPropertyDescriptor(object, prop);
        if (propDesc !== undefined && !propDesc.get || object.__esModule) {
          slots[prop] = true;
        }
      }
    }
    object = parent;
  } while (object && (parent = Object.getPrototypeOf(object)) !== null);
  return Object.keys(slots);
}

var ModuleMockerClass = function () {
  /**
   * @see README.md
   * @param global Global object of the test environment, used to create
   * mocks
   */
  function ModuleMockerClass(global) {
    _classCallCheck(this, ModuleMockerClass);

    this._environmentGlobal = global;
    this._mockState = new WeakMap();
    this._mockConfigRegistry = new WeakMap();
    this._spyState = new Set();
    this.ModuleMocker = ModuleMockerClass;
    this._invocationCallCounter = 1;
  }

  _createClass(ModuleMockerClass, [{
    key: '_ensureMockConfig',
    value: function _ensureMockConfig(f) {
      var config = this._mockConfigRegistry.get(f);
      if (!config) {
        config = this._defaultMockConfig();
        this._mockConfigRegistry.set(f, config);
      }
      return config;
    }
  }, {
    key: '_ensureMockState',
    value: function _ensureMockState(f) {
      var state = this._mockState.get(f);
      if (!state) {
        state = this._defaultMockState();
        this._mockState.set(f, state);
      }
      return state;
    }
  }, {
    key: '_defaultMockConfig',
    value: function _defaultMockConfig() {
      return {
        defaultReturnValue: undefined,
        isReturnValueLastSet: false,
        mockImpl: undefined,
        mockName: 'jest.fn()',
        specificMockImpls: [],
        specificReturnValues: []
      };
    }
  }, {
    key: '_defaultMockState',
    value: function _defaultMockState() {
      return {
        calls: [],
        instances: [],
        invocationCallOrder: [],
        results: []
      };
    }
  }, {
    key: '_makeComponent',
    value: function _makeComponent(metadata, restore) {
      var _this2 = this;

      if (metadata.type === 'object') {
        return new this._environmentGlobal.Object();
      } else if (metadata.type === 'array') {
        return new this._environmentGlobal.Array();
      } else if (metadata.type === 'regexp') {
        return new this._environmentGlobal.RegExp('');
      } else if (metadata.type === 'constant' || metadata.type === 'collection' || metadata.type === 'null' || metadata.type === 'undefined') {
        return metadata.value;
      } else if (metadata.type === 'function') {
        /* eslint-disable prefer-const */
        var f = void 0;
        /* eslint-enable prefer-const */

        var prototype = metadata.members && metadata.members.prototype && metadata.members.prototype.members || {};
        var prototypeSlots = getSlots(prototype);
        var mocker = this;
        var mockConstructor = matchArity(function () {
          var _this = this,
              _arguments = arguments;

          var mockState = mocker._ensureMockState(f);
          var mockConfig = mocker._ensureMockConfig(f);
          mockState.instances.push(this);
          mockState.calls.push(Array.prototype.slice.call(arguments));
          mockState.invocationCallOrder.push(mocker._invocationCallCounter++);

          // Will be set to the return value of the mock if an error is not thrown
          var finalReturnValue = void 0;
          // Will be set to the error that is thrown by the mock (if it throws)
          var thrownError = void 0;
          // Will be set to true if the mock throws an error. The presence of a
          // value in `thrownError` is not a 100% reliable indicator because a
          // function could throw a value of undefined.
          var callDidThrowError = false;

          try {
            // The bulk of the implementation is wrapped in an immediately
            // executed arrow function so the return value of the mock function
            // can be easily captured and recorded, despite the many separate
            // return points within the logic.
            finalReturnValue = function () {
              if (_this instanceof f) {
                // This is probably being called as a constructor
                prototypeSlots.forEach(function (slot) {
                  // Copy prototype methods to the instance to make
                  // it easier to interact with mock instance call and
                  // return values
                  if (prototype[slot].type === 'function') {
                    var protoImpl = _this[slot];
                    _this[slot] = mocker.generateFromMetadata(prototype[slot]);
                    _this[slot]._protoImpl = protoImpl;
                  }
                });

                // Run the mock constructor implementation
                var mockImpl = mockConfig.specificMockImpls.length ? mockConfig.specificMockImpls.shift() : mockConfig.mockImpl;
                return mockImpl && mockImpl.apply(_this, _arguments);
              }

              var returnValue = mockConfig.defaultReturnValue;
              // If return value is last set, either specific or default, i.e.
              // mockReturnValueOnce()/mockReturnValue() is called and no
              // mockImplementationOnce()/mockImplementation() is called after
              // that.
              // use the set return value.
              if (mockConfig.specificReturnValues.length) {
                return mockConfig.specificReturnValues.shift();
              }

              if (mockConfig.isReturnValueLastSet) {
                return mockConfig.defaultReturnValue;
              }

              // If mockImplementationOnce()/mockImplementation() is last set,
              // or specific return values are used up, use the mock
              // implementation.
              var specificMockImpl = void 0;
              if (returnValue === undefined) {
                specificMockImpl = mockConfig.specificMockImpls.shift();
                if (specificMockImpl === undefined) {
                  specificMockImpl = mockConfig.mockImpl;
                }
                if (specificMockImpl) {
                  return specificMockImpl.apply(_this, _arguments);
                }
              }

              // Otherwise use prototype implementation
              if (returnValue === undefined && f._protoImpl) {
                return f._protoImpl.apply(_this, _arguments);
              }

              return returnValue;
            }();
          } catch (error) {
            // Store the thrown error so we can record it, then re-throw it.
            thrownError = error;
            callDidThrowError = true;
            throw error;
          } finally {
            // Record the result of the function
            mockState.results.push({
              isThrow: callDidThrowError,
              value: callDidThrowError ? thrownError : finalReturnValue
            });
          }

          return finalReturnValue;
        }, metadata.length || 0);

        f = this._createMockFunction(metadata, mockConstructor);
        f._isMockFunction = true;
        f.getMockImplementation = function () {
          return _this2._ensureMockConfig(f).mockImpl;
        };

        if (typeof restore === 'function') {
          this._spyState.add(restore);
        }

        this._mockState.set(f, this._defaultMockState());
        this._mockConfigRegistry.set(f, this._defaultMockConfig());

        // $FlowFixMe - defineProperty getters not supported
        Object.defineProperty(f, 'mock', {
          configurable: false,
          enumerable: true,
          get: function get() {
            return _this2._ensureMockState(f);
          },
          set: function set(val) {
            return _this2._mockState.set(f, val);
          }
        });

        f.mockClear = function () {
          _this2._mockState.delete(f);
          return f;
        };

        f.mockReset = function () {
          f.mockClear();
          _this2._mockConfigRegistry.delete(f);
          return f;
        };

        f.mockRestore = function () {
          f.mockReset();
          return restore ? restore() : undefined;
        };

        f.mockReturnValueOnce = function (value) {
          // next function call will return this value or default return value
          var mockConfig = _this2._ensureMockConfig(f);
          mockConfig.specificReturnValues.push(value);
          return f;
        };

        f.mockResolvedValueOnce = function (value) {
          return f.mockImplementationOnce(function () {
            return Promise.resolve(value);
          });
        };

        f.mockRejectedValueOnce = function (value) {
          return f.mockImplementationOnce(function () {
            return Promise.reject(value);
          });
        };

        f.mockReturnValue = function (value) {
          // next function call will return specified return value or this one
          var mockConfig = _this2._ensureMockConfig(f);
          mockConfig.isReturnValueLastSet = true;
          mockConfig.defaultReturnValue = value;
          return f;
        };

        f.mockResolvedValue = function (value) {
          return f.mockImplementation(function () {
            return Promise.resolve(value);
          });
        };

        f.mockRejectedValue = function (value) {
          return f.mockImplementation(function () {
            return Promise.reject(value);
          });
        };

        f.mockImplementationOnce = function (fn) {
          // next function call will use this mock implementation return value
          // or default mock implementation return value
          var mockConfig = _this2._ensureMockConfig(f);
          mockConfig.isReturnValueLastSet = false;
          mockConfig.specificMockImpls.push(fn);
          return f;
        };

        f.mockImplementation = function (fn) {
          // next function call will use mock implementation return value
          var mockConfig = _this2._ensureMockConfig(f);
          mockConfig.isReturnValueLastSet = false;
          mockConfig.defaultReturnValue = undefined;
          mockConfig.mockImpl = fn;
          return f;
        };

        f.mockReturnThis = function () {
          return f.mockImplementation(function () {
            return this;
          });
        };

        f.mockName = function (name) {
          if (name) {
            var mockConfig = _this2._ensureMockConfig(f);
            mockConfig.mockName = name;
          }
          return f;
        };

        f.getMockName = function () {
          var mockConfig = _this2._ensureMockConfig(f);
          return mockConfig.mockName || 'jest.fn()';
        };

        if (metadata.mockImpl) {
          f.mockImplementation(metadata.mockImpl);
        }

        return f;
      } else {
        var unknownType = metadata.type || 'undefined type';
        throw new Error('Unrecognized type ' + unknownType);
      }
    }
  }, {
    key: '_createMockFunction',
    value: function _createMockFunction(metadata, mockConstructor) {
      var name = metadata.name;
      if (!name) {
        return mockConstructor;
      }

      // Preserve `name` property of mocked function.
      var boundFunctionPrefix = 'bound ';
      var bindCall = '';
      // if-do-while for perf reasons. The common case is for the if to fail.
      if (name && name.startsWith(boundFunctionPrefix)) {
        do {
          name = name.substring(boundFunctionPrefix.length);
          // Call bind() just to alter the function name.
          bindCall = '.bind(null)';
        } while (name && name.startsWith(boundFunctionPrefix));
      }

      // Special case functions named `mockConstructor` to guard for infinite
      // loops.
      if (name === MOCK_CONSTRUCTOR_NAME) {
        return mockConstructor;
      }

      // It's a syntax error to define functions with a reserved keyword
      // as name.
      if (RESERVED_KEYWORDS[name]) {
        name = '$' + name;
      }

      // It's also a syntax error to define a function with a reserved character
      // as part of it's name.
      if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {
        name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');
      }

      var body = 'return function ' + name + '() {' + 'return ' + MOCK_CONSTRUCTOR_NAME + '.apply(this,arguments);' + '}' + bindCall;
      var createConstructor = new this._environmentGlobal.Function(MOCK_CONSTRUCTOR_NAME, body);

      return createConstructor(mockConstructor);
    }
  }, {
    key: '_generateMock',
    value: function _generateMock(metadata, callbacks, refs) {
      var _this3 = this;

      var mock = this._makeComponent(metadata);
      if (metadata.refID != null) {
        refs[metadata.refID] = mock;
      }

      getSlots(metadata.members).forEach(function (slot) {
        var slotMetadata = metadata.members && metadata.members[slot] || {};
        if (slotMetadata.ref != null) {
          callbacks.push(function () {
            return mock[slot] = refs[slotMetadata.ref];
          });
        } else {
          mock[slot] = _this3._generateMock(slotMetadata, callbacks, refs);
        }
      });

      if (metadata.type !== 'undefined' && metadata.type !== 'null' && mock.prototype) {
        mock.prototype.constructor = mock;
      }

      return mock;
    }

    /**
     * @see README.md
     * @param metadata Metadata for the mock in the schema returned by the
     * getMetadata method of this module.
     */

  }, {
    key: 'generateFromMetadata',
    value: function generateFromMetadata(_metadata) {
      var callbacks = [];
      var refs = {};
      var mock = this._generateMock(_metadata, callbacks, refs);
      callbacks.forEach(function (setter) {
        return setter();
      });
      return mock;
    }

    /**
     * @see README.md
     * @param component The component for which to retrieve metadata.
     */

  }, {
    key: 'getMetadata',
    value: function getMetadata(component, _refs) {
      var _this4 = this;

      var refs = _refs || new Map();
      var ref = refs.get(component);
      if (ref != null) {
        return { ref: ref };
      }

      var type = getType(component);
      if (!type) {
        return null;
      }

      var metadata = { type: type };
      if (type === 'constant' || type === 'collection' || type === 'undefined' || type === 'null') {
        metadata.value = component;
        return metadata;
      } else if (type === 'function') {
        metadata.name = component.name;
        if (component._isMockFunction) {
          metadata.mockImpl = component.getMockImplementation();
        }
      }

      metadata.refID = refs.size;
      refs.set(component, metadata.refID);

      var members = null;
      // Leave arrays alone
      if (type !== 'array') {
        if (type !== 'undefined') {
          getSlots(component).forEach(function (slot) {
            if (type === 'function' && component._isMockFunction && slot.match(/^mock/)) {
              return;
            }

            if (!component.hasOwnProperty && component[slot] !== undefined || component.hasOwnProperty && component.hasOwnProperty(slot) || type === 'object' && component[slot] != Object.prototype[slot]) {
              var slotMetadata = _this4.getMetadata(component[slot], refs);
              if (slotMetadata) {
                if (!members) {
                  members = {};
                }
                members[slot] = slotMetadata;
              }
            }
          });
        }

        // If component is native code function, prototype might be undefined
        if (type === 'function' && component.prototype) {
          var prototype = this.getMetadata(component.prototype, refs);
          if (prototype && prototype.members) {
            if (!members) {
              members = {};
            }
            members.prototype = prototype;
          }
        }
      }

      if (members) {
        metadata.members = members;
      }

      return metadata;
    }
  }, {
    key: 'isMockFunction',
    value: function isMockFunction(fn) {
      return !!(fn && fn._isMockFunction);
    }
  }, {
    key: 'fn',
    value: function fn(implementation) {
      var length = implementation ? implementation.length : 0;
      var fn = this._makeComponent({ length: length, type: 'function' });
      if (implementation) {
        fn.mockImplementation(implementation);
      }
      return fn;
    }
  }, {
    key: 'spyOn',
    value: function spyOn(object, methodName, accessType) {
      if (accessType) {
        return this._spyOnProperty(object, methodName, accessType);
      }

      if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object' && typeof object !== 'function') {
        throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given');
      }

      var original = object[methodName];

      if (!this.isMockFunction(original)) {
        if (typeof original !== 'function') {
          throw new Error('Cannot spy the ' + methodName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');
        }

        object[methodName] = this._makeComponent({ type: 'function' }, function () {
          object[methodName] = original;
        });

        object[methodName].mockImplementation(function () {
          return original.apply(this, arguments);
        });
      }

      return object[methodName];
    }
  }, {
    key: '_spyOnProperty',
    value: function _spyOnProperty(obj, propertyName) {
      var accessType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'get';

      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && typeof obj !== 'function') {
        throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given');
      }

      if (!obj) {
        throw new Error('spyOn could not find an object to spy upon for ' + propertyName + '');
      }

      if (!propertyName) {
        throw new Error('No property name supplied');
      }

      var descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
      var proto = Object.getPrototypeOf(obj);

      while (!descriptor && proto !== null) {
        descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);
        proto = Object.getPrototypeOf(proto);
      }

      if (!descriptor) {
        throw new Error(propertyName + ' property does not exist');
      }

      if (!descriptor.configurable) {
        throw new Error(propertyName + ' is not declared configurable');
      }

      if (!descriptor[accessType]) {
        throw new Error('Property ' + propertyName + ' does not have access type ' + accessType);
      }

      var original = descriptor[accessType];

      if (!this.isMockFunction(original)) {
        if (typeof original !== 'function') {
          throw new Error('Cannot spy the ' + propertyName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');
        }

        descriptor[accessType] = this._makeComponent({ type: 'function' }, function () {
          // $FlowFixMe
          descriptor[accessType] = original;
          // $FlowFixMe
          Object.defineProperty(obj, propertyName, descriptor);
        });

        descriptor[accessType].mockImplementation(function () {
          return original.apply(this, arguments);
        });
      }

      Object.defineProperty(obj, propertyName, descriptor);
      return descriptor[accessType];
    }
  }, {
    key: 'clearAllMocks',
    value: function clearAllMocks() {
      this._mockState = new WeakMap();
    }
  }, {
    key: 'resetAllMocks',
    value: function resetAllMocks() {
      this._mockConfigRegistry = new WeakMap();
      this._mockState = new WeakMap();
    }
  }, {
    key: 'restoreAllMocks',
    value: function restoreAllMocks() {
      this._spyState.forEach(function (restore) {
        return restore();
      });
      this._spyState = new Set();
    }
  }, {
    key: '_typeOf',
    value: function _typeOf(value) {
      return value == null ? '' + value : typeof value === 'undefined' ? 'undefined' : _typeof(value);
    }
  }]);

  return ModuleMockerClass;
}();

module.exports = new ModuleMockerClass(global);