'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jestDiff = require('jest-diff');

var _jestDiff2 = _interopRequireDefault(_jestDiff);

var _jestMatcherUtils = require('jest-matcher-utils');

var _State = require('./State');

var _State2 = _interopRequireDefault(_State);

var _plugins = require('./plugins');

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

var fileExists = function fileExists(filePath, hasteFS) {
  return hasteFS.exists(filePath) || _fs2.default.existsSync(filePath);
};

var cleanup = function cleanup(hasteFS, update) {
  var pattern = '\\.' + utils.SNAPSHOT_EXTENSION + '$';
  var files = hasteFS.matchFiles(pattern);
  var filesRemoved = files.filter(function (snapshotFile) {
    return !fileExists(_path2.default.resolve(_path2.default.dirname(snapshotFile), '..', _path2.default.basename(snapshotFile, '.' + utils.SNAPSHOT_EXTENSION)), hasteFS);
  }).map(function (snapshotFile) {
    if (update === 'all') {
      _fs2.default.unlinkSync(snapshotFile);
    }
  }).length;

  return {
    filesRemoved: filesRemoved
  };
};

var toMatchSnapshot = function toMatchSnapshot(received, propertyMatchers, testName) {
  if (arguments.length === 3 && !propertyMatchers) {
    throw new Error('Property matchers must be an object.\n\nTo provide a snapshot test name without property matchers, use: toMatchSnapshot("name")');
  }

  return _toMatchSnapshot({
    context: this,
    propertyMatchers: propertyMatchers,
    received: received,
    testName: testName
  });
};

var toMatchInlineSnapshot = function toMatchInlineSnapshot(received, propertyMatchersOrInlineSnapshot, inlineSnapshot) {
  var propertyMatchers = void 0;
  if (typeof propertyMatchersOrInlineSnapshot === 'string') {
    inlineSnapshot = propertyMatchersOrInlineSnapshot;
  } else {
    propertyMatchers = propertyMatchersOrInlineSnapshot;
  }
  return _toMatchSnapshot({
    context: this,
    inlineSnapshot: inlineSnapshot || '',
    propertyMatchers: propertyMatchers,
    received: received
  });
};

var _toMatchSnapshot = function _toMatchSnapshot(_ref) {
  var context = _ref.context,
      received = _ref.received,
      propertyMatchers = _ref.propertyMatchers,
      testName = _ref.testName,
      inlineSnapshot = _ref.inlineSnapshot;

  context.dontThrow && context.dontThrow();
  testName = typeof propertyMatchers === 'string' ? propertyMatchers : testName;

  var currentTestName = context.currentTestName,
      isNot = context.isNot,
      snapshotState = context.snapshotState;

  if (isNot) {
    var matcherName = typeof inlineSnapshot === 'string' ? 'toMatchInlineSnapshot' : 'toMatchSnapshot';
    throw new Error('Jest: `.not` cannot be used with `.' + matcherName + '()`.');
  }

  if (!snapshotState) {
    throw new Error('Jest: snapshot state must be initialized.');
  }

  var fullTestName = testName && currentTestName ? currentTestName + ': ' + testName : currentTestName || '';

  if ((typeof propertyMatchers === 'undefined' ? 'undefined' : _typeof(propertyMatchers)) === 'object') {
    if (propertyMatchers === null) {
      throw new Error('Property matchers must be an object.');
    }
    var propertyPass = context.equals(received, propertyMatchers, [context.utils.iterableEquality, context.utils.subsetEquality]);

    if (!propertyPass) {
      var key = snapshotState.fail(fullTestName, received);

      var _report = function _report() {
        return (0, _jestMatcherUtils.RECEIVED_COLOR)('Received value') + ' does not match ' + ((0, _jestMatcherUtils.EXPECTED_COLOR)('snapshot properties for "' + key + '"') + '.\n\n') + 'Expected snapshot to match properties:\n' + ('  ' + context.utils.printExpected(propertyMatchers)) + '\nReceived:\n' + ('  ' + context.utils.printReceived(received));
      };

      return {
        message: function message() {
          return (0, _jestMatcherUtils.matcherHint)('.toMatchSnapshot', 'value', 'properties') + '\n\n' + _report();
        },
        name: 'toMatchSnapshot',
        pass: false,
        report: _report
      };
    } else {
      received = utils.deepMerge(received, propertyMatchers);
    }
  }

  var result = snapshotState.match({
    error: context.error,
    inlineSnapshot: inlineSnapshot,
    received: received,
    testName: fullTestName
  });
  var pass = result.pass;
  var actual = result.actual,
      expected = result.expected;

  var report = void 0;
  if (pass) {
    return { message: function message() {
        return '';
      }, pass: true };
  } else if (!expected) {
    report = function report() {
      return 'New snapshot was ' + (0, _jestMatcherUtils.RECEIVED_COLOR)('not written') + '. The update flag ' + 'must be explicitly passed to write a new snapshot.\n\n' + 'This is likely because this test is run in a continuous integration ' + '(CI) environment in which snapshots are not written by default.\n\n' + ((0, _jestMatcherUtils.RECEIVED_COLOR)('Received value') + ' ') + ('' + actual);
    };
  } else {
    expected = (expected || '').trim();
    actual = (actual || '').trim();
    var diffMessage = (0, _jestDiff2.default)(expected, actual, {
      aAnnotation: 'Snapshot',
      bAnnotation: 'Received',
      expand: snapshotState.expand
    });

    report = function report() {
      return (0, _jestMatcherUtils.RECEIVED_COLOR)('Received value') + ' does not match ' + ((0, _jestMatcherUtils.EXPECTED_COLOR)('stored snapshot "' + result.key + '"') + '.\n\n') + (diffMessage || (0, _jestMatcherUtils.EXPECTED_COLOR)('- ' + (expected || '')) + '\n' + (0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + actual));
    };
  }
  // Passing the the actual and expected objects so that a custom reporter
  // could access them, for example in order to display a custom visual diff,
  // or create a different error message
  return {
    actual: actual,
    expected: expected,
    message: function message() {
      return (0, _jestMatcherUtils.matcherHint)('.toMatchSnapshot', 'value', '') + '\n\n' + report();
    },
    name: 'toMatchSnapshot',
    pass: false,
    report: report
  };
};

var toThrowErrorMatchingSnapshot = function toThrowErrorMatchingSnapshot(received, testName, fromPromise) {
  return _toThrowErrorMatchingSnapshot({
    context: this,
    fromPromise: fromPromise,
    received: received,
    testName: testName
  });
};

var toThrowErrorMatchingInlineSnapshot = function toThrowErrorMatchingInlineSnapshot(received, inlineSnapshot, fromPromise) {
  return _toThrowErrorMatchingSnapshot({
    context: this,
    fromPromise: fromPromise,
    inlineSnapshot: inlineSnapshot || '',
    received: received
  });
};

var _toThrowErrorMatchingSnapshot = function _toThrowErrorMatchingSnapshot(_ref2) {
  var context = _ref2.context,
      received = _ref2.received,
      testName = _ref2.testName,
      fromPromise = _ref2.fromPromise,
      inlineSnapshot = _ref2.inlineSnapshot;

  context.dontThrow && context.dontThrow();
  var isNot = context.isNot;

  var matcherName = typeof inlineSnapshot === 'string' ? 'toThrowErrorMatchingInlineSnapshot' : 'toThrowErrorMatchingSnapshot';

  if (isNot) {
    throw new Error('Jest: `.not` cannot be used with `.' + matcherName + '()`.');
  }

  var error = void 0;

  if (fromPromise) {
    error = received;
  } else {
    try {
      received();
    } catch (e) {
      error = e;
    }
  }

  if (error === undefined) {
    throw new Error((0, _jestMatcherUtils.matcherHint)('.' + matcherName, '() => {}', '') + '\n\n' + 'Expected the function to throw an error.\n' + 'But it didn\'t throw anything.');
  }

  return _toMatchSnapshot({
    context: context,
    inlineSnapshot: inlineSnapshot,
    received: error.message,
    testName: testName
  });
};

module.exports = {
  EXTENSION: utils.SNAPSHOT_EXTENSION,
  SnapshotState: _State2.default,
  addSerializer: _plugins.addSerializer,
  cleanup: cleanup,
  getSerializers: _plugins.getSerializers,
  toMatchInlineSnapshot: toMatchInlineSnapshot,
  toMatchSnapshot: toMatchSnapshot,
  toThrowErrorMatchingInlineSnapshot: toThrowErrorMatchingInlineSnapshot,
  toThrowErrorMatchingSnapshot: toThrowErrorMatchingSnapshot,
  utils: utils
};