'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var pMap = require('p-map');
var Task = require('./lib/task');
var TaskWrapper = require('./lib/task-wrapper');
var renderer = require('./lib/renderer');
var ListrError = require('./lib/listr-error');

var runTask = function runTask(task, context, errors) {
	if (!task.isEnabled()) {
		return Promise.resolve();
	}

	return new TaskWrapper(task, errors).run(context);
};

var Listr = function () {
	function Listr(tasks, opts) {
		_classCallCheck(this, Listr);

		if (tasks && !Array.isArray(tasks) && (typeof tasks === 'undefined' ? 'undefined' : _typeof(tasks)) === 'object') {
			if (typeof tasks.title === 'string' && typeof tasks.task === 'function') {
				throw new TypeError('Expected an array of tasks or an options object, got a task object');
			}

			opts = tasks;
			tasks = [];
		}

		if (tasks && !Array.isArray(tasks)) {
			throw new TypeError('Expected an array of tasks');
		}

		this._options = Object.assign({
			showSubtasks: true,
			concurrent: false,
			renderer: 'default',
			nonTTYRenderer: 'verbose'
		}, opts);
		this._tasks = [];

		this.concurrency = 1;
		if (this._options.concurrent === true) {
			this.concurrency = Infinity;
		} else if (typeof this._options.concurrent === 'number') {
			this.concurrency = this._options.concurrent;
		}

		this._RendererClass = renderer.getRenderer(this._options.renderer, this._options.nonTTYRenderer);

		this.exitOnError = this._options.exitOnError;

		this.add(tasks || []);
	}

	_createClass(Listr, [{
		key: '_checkAll',
		value: function _checkAll(context) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._tasks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var task = _step.value;

					task.check(context);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}
	}, {
		key: 'setRenderer',
		value: function setRenderer(value) {
			this._RendererClass = renderer.getRenderer(value);
		}
	}, {
		key: 'add',
		value: function add(task) {
			var tasks = Array.isArray(task) ? task : [task];

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = tasks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var _task = _step2.value;

					this._tasks.push(new Task(this, _task, this._options));
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return this;
		}
	}, {
		key: 'render',
		value: function render() {
			if (!this._renderer) {
				this._renderer = new this._RendererClass(this._tasks, this._options);
			}

			return this._renderer.render();
		}
	}, {
		key: 'run',
		value: function run(context) {
			var _this = this;

			this.render();

			context = context || Object.create(null);

			var errors = [];

			this._checkAll(context);

			var tasks = pMap(this._tasks, function (task) {
				_this._checkAll(context);
				return runTask(task, context, errors);
			}, { concurrency: this.concurrency });

			return tasks.then(function () {
				if (errors.length > 0) {
					var err = new ListrError('Something went wrong');
					err.errors = errors;
					throw err;
				}

				_this._renderer.end();

				return context;
			}).catch(function (error) {
				error.context = context;
				_this._renderer.end(error);
				throw error;
			});
		}
	}, {
		key: 'tasks',
		get: function get() {
			return this._tasks;
		}
	}]);

	return Listr;
}();

module.exports = Listr;